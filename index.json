[{"categories":null,"contents":"Hugo is a static site engine written in Go.\nIt makes use of a variety of open source projects including:\nCobra Viper J Walter Weatherman Cast Learn more and contribute on GitHub.\n","permalink":"https://omgkill.github.io/about/","tags":null,"title":"About"},{"categories":["git"],"contents":"git 使用 远程仓库的使用 查看远程仓库\ngit remote 看到origin 这是git给你克隆的仓库服务器的 默认名字 git remote -v 会显示名字与url，拉取与推送会独立显示 添加远程仓库\ngit remote add 从远程仓库拉取\ngit fetch [remote-name] fetch 命令会将数据拉去到你的本地仓库，它并不会自动合并或修改你当前的工作。当准备好时你必须手动将其合并入你的工作 git clone\n命令会自动将其添加为远程仓库 并默认以‘origin’ 为简写 git fetch origin 会抓取克隆（或上次抓取）后新推送的所有工作 会自动设置本地master分支跟踪克隆的远程仓库的master分支 git pull\n自动抓取然后合并远程分支到当前分支 fetch 与pull区别\ngit fetch：从远程获取最新版本到本地，但不会自动 merge，用于从远程跟踪分支下载和查看其他人完成的最新提交，但不将这些提交合并到本地存储库中。它从远程存储库中获取更改并将其存储在本地存储库中。\ngit pull：从远程获取最新版本并 merge 到本地，它会自动将提交合并到您的本地存储库中，而无需查看提交。\n参考：https://worktile.com/kb/ask/22877.html\n查看分支\ngit branch -a *rebase和merge区别*\n参考：https://baijiahao.baidu.com/s?id=1726894961804450124\u0026amp;wfr=spider\u0026amp;for=pc\ngit IDEA的分支合并时的冲突问题总结，merge和rebase的区别_rebase和merge的区别_YHJ的博客-CSDN博客\n撤回\n在当前分支，打开终端，执行命令回退 git reset --hard commit_id。 推送到远程仓库\ngit push origin master 如果远程仓库与本地有冲突，可以先把master拉取下来合并，解决完冲突，再推送 查看远程仓库\ngit remote show [remote-name] 实例：git remote show origin 本地远程仓库的重命名\ngit remote rename [原名字] [新名字] git remote rename pb paul git remote 查看本地简称是否修改 本地远程仓库的删除\ngit remote rm paul 打标签 列出标签 git tag 搜索查找 git tag -l ’v1.8.5*‘ 标签类型 轻量标签 很像一个不会改变的分支-它知识一个特定提交的引用 附注标签 时存储再git数据库中的一个完整对象，他们可以被校验的：其中包括打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用GUN Privacy Guard(GPG)签名与验证 创建附注标签 git tag -a v1.4 -m ‘my version 1.4’ -m 选项指定一个将会存储再标签中的信息 git show v1.4 查看提交信息 创建轻量标签 git tag v1.4 后期打标签 可以对过去的提交打标签 查看log， git log —pretty=online git tag -a v1.2 [校验和，也就是commentId] 共享标签 默认情况下，git push 命令不会传送标签到远程仓库服务器上 git push origin [tagname] 一次性推送很多标签 git push origin \u0026ndash; tags 检出标签 git checkout -b [branchname] [tagname]7887 示例：git checkout -b version2 v2.0.0 Git 别名 git config \u0026ndash;global alias.co checkout git config —global alias.ci commit 当输入git commit时，只需要输入git ci 为解决取消暂存文件的易用性问题，可以向Git添加自己的取消暂存别名： git config —global alias.unstage ‘reset HEAD —’ 这会使下面的两个命令等价： git unstage fileA git reset HEAD — fileA 如果想要执行外部命令，需要在命令前面加入！符号 git config —global alias.visual ‘!gitk’ Git 分支 查看各个分支当前所指的对象 git log —oneline —decorate 切换分支 git checkout testing 查看分叉历史 git log —oneline —decorate —graph -all 分支的新建和合并 现在有个bug，需要修复。流程如下 创建issue分支 git checkout - b iss53 提交了修复代码 线上有个紧急问题 git checkout master git checkout - b hotfix 修改提交 运行测试 git checkout master git merge hotfix fast-forward ，由于当前master分支所指向的提交是你当前提交的直接上游，所以git只是简单的将指针向前移动。 git branch -d hotfix git checkout iss53 如果想要hotfix的修改，可以git merge master 分支管理 获取当前分支列表 git branch *代表现在检出的那一个分支 查看每一个分支最后的提交 git branch -v 查看哪些分支已经合并到当前分支 git branch —merged 删除分支 git branch -d 强制删除 git branch -D 查看所有包含未合并工作的分支 git branch —no-merged 分支开发工作流程 显示的获取远程引用的完整列表 git ls-remote git remote show [仓库名] 获得远程分支的更多信息 创建分支 正常的：git checkout -b [branch] [remotename]/[branch] 快捷方式：git checkout —track origin/serverfix 修改上游分支 git branch -u origin/serverfix 查看设置的所有跟踪分支 git branch -vv 更新仓库数据 git fetch —all 删除远程分支 git push origin —delete serverfix 合并 merge 与 rebase，这两种整合方法的最终结果没有任何区别，但是rebase使得提交历史中更加整洁。你在查看一个经过rebase的分支历史记录时会发现，尽管实际的开发工作时并行的，但它们看上去就像时先后串行的一样，提交历史是一条直线没有分叉 无论通过rebase还是第三方合并，整合的最终结果所指向的快照始终时一样的，只不过提交历史不同罢了。rebase是将一系列提交按照原有次序依次应用到另一分支上，而合并是最终结果合在一起。 有趣的rebase 例子 创建分支server，提交C3,C4 从C3创建特性分支client，提交C8,C9 回到server分支，提交C10 假设你希望将client中的修改合并到主分支并发布，但暂时并不想合并server中的修改，因为它们还需要经过更全面的测试 git rebase —onto master server client 这个意思是，把client与server的共同祖先合并 git checkout master git merge client server也合并master git rebase master server rebase的风险 不要对在你的仓库外有副本的分支执行rebase 如果别人，push后，又 重新rebase，需要使用这个命令 git pull —rebase 相当于：git fetch , git rebase master 总的原则，只对尚未推送或分享给别人的本地修改执行rebase操作清理历史，从不对已推送至别处的提交执行rebase操作，这样，你才能享受到两种方式带来的便利 提交准则 空白错误检查 git diff —check 暂存文件 git add —patch 优质提交信息的习惯会使Git的使用与协作容易的多 向一个项目贡献 带上-u 参数其实就相当于记录了push到远端分支的默认值，这样当下次我们还想要继续push的这个远端分支的时候推送命令就可以简写成git push即可。 git push -u origin featureA -u 是 —set-upstream的简写，该标记为之后轻松地推送和拉去配置分支 推送远程分支,featureB是本地分支，featureBee是远程分支 git push -u origin featureB:featureBee 日志过滤器，要i求Git只显示所有在后面分支，但不在前面分支的提交列表 git log issue54..origin/master 另一个例子：git log featureA..origin/featureA 没有合并日志git log —no-merge issue54..origin/master 派生的公开项目 合并修改 先把目标克隆到本地 提交修改 github上，fork目标项目到自己账号下 添加自己的远程仓库地址，git remote add myfork (url) git push -u myfork featureA 发送拉去请求 —squash 选项接受被合并的分支上的所有工作，并将其压缩至一个变更集，是仓库变成一个真正的合并的状态，而不会真的生成一个合并提交 —no-commit 选项在默认合并过程中可以用来延迟生成合并提交 维护项目 应用邮件补丁 使用apply命令应用补丁 git apply /temp/patch-ruby-client.patch git apply 与 patch -p1 命令来应用补丁几乎是等效的，但这种方式更严格。 git apply命令采用了一种“全部应用，否则全部撤销” 可以使用git apply 来检查补丁是否可以顺利应用 git apply —check xxx.patch 使用am命令应用补丁 找到分支的共同祖先 git merge-base contrib master git diff master..contrib 该命令仅会显示自当前特性分支与master分支的共同祖先起，该分支中的工作。 另一种将引入的工作转移到其他分支的方法是拣选。 git cherry-pick [git commit id] 为发布打标签 git tag -s v1.5 -m ‘my signed 1.5 tag’ 快照归档 git archive master —prefix=’project/’ | gzip \u0026gt; ‘git describe master’.tar.gz 制作提交简报 git shortlog —no-merges mater —not v1.0.1 ","permalink":"https://omgkill.github.io/post/git/git%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":["git"],"title":"git 使用"},{"categories":null,"contents":"wiki.js 安装搜索 整体安装，参考 https://www.bilibili.com/read/cv16951722/ 参考安装ElasticSearch https://zhuanlan.zhihu.com/p/257867352 安装好后，需要rebuild Note that if you already have content in your wiki, you must click on Rebuild Index afterwards to import all your existing content into the search engine. Any change (new, edit, delete page) will be handled automatically from this point forward.\nYour content here\n","permalink":"https://omgkill.github.io/bak/%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/wikijs/wiki%E6%90%9C%E7%B4%A2/","tags":null,"title":"wiki搜索"},{"categories":null,"contents":"wiki.js 安装搜索 整体安装，参考 https://www.bilibili.com/read/cv16951722/ 参考安装ElasticSearch https://zhuanlan.zhihu.com/p/257867352 安装好后，需要rebuild Note that if you already have content in your wiki, you must click on Rebuild Index afterwards to import all your existing content into the search engine. Any change (new, edit, delete page) will be handled automatically from this point forward.\nYour content here\n","permalink":"https://omgkill.github.io/post/knowledgesite/wiki%E6%90%9C%E7%B4%A2/","tags":null,"title":"wiki搜索"},{"categories":null,"contents":"部署WIKI.js wiki的介绍地址\nhttps://sspai.com/post/78945 wiki 的docker compose文件\n1version: \u0026#34;3\u0026#34; 2services: 3 4 db: 5 image: postgres:11-alpine 6 environment: 7 POSTGRES_DB: wiki 8 POSTGRES_PASSWORD: wikijsrocks 9 POSTGRES_USER: wikijs 10 logging: 11 driver: \u0026#34;none\u0026#34; 12 restart: unless-stopped 13 volumes: 14 - db-data:/var/lib/postgresql/data 15 16 wiki: 17 image: ghcr.io/requarks/wiki:2 18 depends_on: 19 - db 20 environment: 21 DB_TYPE: postgres 22 DB_HOST: db 23 DB_PORT: 5432 24 DB_USER: wikijs 25 DB_PASS: wikijsrocks 26 DB_NAME: wiki 27 restart: unless-stopped 28 ports: 29 - \u0026#34;80:3000\u0026#34; 30 31volumes: 32 db-data: 安装docker\nyum install -y docker 安装docker compose\ncurl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s-uname -m` \u0026gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose \u0026gt; /etc/bash_completion.d/docker-compose 报错1:Cannot connect to the Docker daemon at unix:///var/run/docker.sock\nmv /usr/bin/systemctl /usr/bin/systemctl.old curl https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl.py \u0026gt; /usr/bin/systemctl chmod +x /usr/bin/systemctl 在cmd下， wsl \u0026ndash;shutdown 在cmd下， wsl 启动服务\nservice docker start docker-compose up -d 报错2:wsl Cannot start service db: oci runtime error: systemd cgroup flag passed, but systemd support for mana\n1I just performed the following steps, and it appears that the error has disappeared. FYI. 2 3Re-enable Hyper-V and restart the computer. 4Edit (or create) the file /etc/wsl.conf in WSL, and add the follow lines: 5[boot] 6systemd=true 7Run wsl --shutdown as an administrator in PowerShell to close the WSL instance, and then restart WSL. 8After logging back into WSL, I found that the systemctl command could be used properly and the error had disappeared. At the moment, my Docker seems to be running well. - 参考：https://github.com/microsoft/WSL/issues/9868 ","permalink":"https://omgkill.github.io/bak/%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/wikijs/%E5%88%9B%E5%BB%BAwiki.js/","tags":null,"title":"创建wiki.js"},{"categories":null,"contents":"部署WIKI.js wiki的介绍地址\nhttps://sspai.com/post/78945 wiki 的docker compose文件\n1version: \u0026#34;3\u0026#34; 2services: 3 4 db: 5 image: postgres:11-alpine 6 environment: 7 POSTGRES_DB: wiki 8 POSTGRES_PASSWORD: wikijsrocks 9 POSTGRES_USER: wikijs 10 logging: 11 driver: \u0026#34;none\u0026#34; 12 restart: unless-stopped 13 volumes: 14 - db-data:/var/lib/postgresql/data 15 16 wiki: 17 image: ghcr.io/requarks/wiki:2 18 depends_on: 19 - db 20 environment: 21 DB_TYPE: postgres 22 DB_HOST: db 23 DB_PORT: 5432 24 DB_USER: wikijs 25 DB_PASS: wikijsrocks 26 DB_NAME: wiki 27 restart: unless-stopped 28 ports: 29 - \u0026#34;80:3000\u0026#34; 30 31volumes: 32 db-data: 安装docker\nyum install -y docker 安装docker compose\ncurl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s-uname -m` \u0026gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose \u0026gt; /etc/bash_completion.d/docker-compose 报错1:Cannot connect to the Docker daemon at unix:///var/run/docker.sock\nmv /usr/bin/systemctl /usr/bin/systemctl.old curl https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl.py \u0026gt; /usr/bin/systemctl chmod +x /usr/bin/systemctl 在cmd下， wsl \u0026ndash;shutdown 在cmd下， wsl 启动服务\nservice docker start docker-compose up -d 报错2:wsl Cannot start service db: oci runtime error: systemd cgroup flag passed, but systemd support for mana\n1I just performed the following steps, and it appears that the error has disappeared. FYI. 2 3Re-enable Hyper-V and restart the computer. 4Edit (or create) the file /etc/wsl.conf in WSL, and add the follow lines: 5[boot] 6systemd=true 7Run wsl --shutdown as an administrator in PowerShell to close the WSL instance, and then restart WSL. 8After logging back into WSL, I found that the systemctl command could be used properly and the error had disappeared. At the moment, my Docker seems to be running well. - 参考：https://github.com/microsoft/WSL/issues/9868 ","permalink":"https://omgkill.github.io/post/knowledgesite/%E5%88%9B%E5%BB%BAwiki.js/","tags":null,"title":"创建wiki.js"},{"categories":null,"contents":"一块复杂的代码如何写 以优化来了，需要加一点逻辑。但加这点逻辑导致代码逻辑更复杂。应该如何写呢 方案有以下几种 改动最小，代码逻辑正常跑，但不容易理解，且理解错误 改动中等，但逻辑混乱 改动整体，但业务逻辑分离封装，更容易理解 Your content here ","permalink":"https://omgkill.github.io/bak/%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E7%9A%84%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91/","tags":null,"title":"代码"},{"categories":null,"contents":"代码解决方案\n1. 问题：逻辑有点复杂，还要在复杂的逻辑上修改\r- 解决方案：\r- 1. 改动小，代码执行是没问题。但不容易理解\r- 2. 改动大，代码是解构的。更容易理解\r- 最终解决\r- 选择的方案2\r- 原因：\r- 结构清晰，更容易理解\r- reviewer也更容易看明白，确保没有问题\r2. 问题：leader希望复用共同的逻辑，但配置却是独立的，没有用共同的。同时配置又深入嵌入到逻辑的各处\r- leader希望的\r- 复用共同逻辑，可以用模板方法解决\r- 我一开始的做法\r- 只共用一个接口，逻辑代码是copy的\r- 这样就又冲突了。\r- 最后方案\r- 使用适配器模式，通过一个配置类关联两个独立的配置\r- 这样底层的配置读取就是共同的，不需要做特殊处理。后续相关的活动也可以这样处理\r- 创建一个stage类，然后再创建stageGc类并继承stage。同时一个配置解析类\r","permalink":"https://omgkill.github.io/post/%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","tags":["代码"],"title":"代码解决方案"},{"categories":["docker"],"contents":"#Docker 跨主机容器通信实践\nDockerOverlay网络\nOverlay是一种覆盖在主机上的虚拟网络，我理解的overlay他需要借助插件或工具完成对数据的保存和转发。我们这里使用etcd来完成overlay的跨主机容器通信 本文以两台机器为例，ip分配是 10.0.3.2 与 10.0.3.21\n检查两台机器hostname是否不同，如果相同需要修改。不然无法联通\n两台机器安装docker\nyum install -y docker 修改docker配置,指定外部存储使用etcd，/etc/docker/daemon.json 加如下数据\n主机10.0.3.2 \u0026ldquo;cluster-store\u0026rdquo;:\u0026ldquo;etcd://10.0.3.2:2379\u0026rdquo;,\u0026ldquo;cluster-advertise\u0026rdquo;:\u0026ldquo;10.0.3.2:2375\u0026rdquo; 主机10.0.3.21 \u0026ldquo;cluster-store\u0026rdquo;:\u0026ldquo;etcd://10.0.3.21:2379\u0026rdquo;,\u0026ldquo;cluster-advertise\u0026rdquo;:\u0026ldquo;10.0.3.21:2375\u0026rdquo; 重启docker\nsystemctl daemon-reload systemctl restart docker 启动etcd\n主机10.0.3.2, etcd节点名为node1 1 docker run -d --name etcd --rm \\ 2 --publish 2379:2379 \\ 3 --publish 2380:2380 \\ 4 --env ALLOW_NONE_AUTHENTICATION=yes \\ 5 --env ETCD_NAME=node1 \\ 6 --env ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380 \\ 7 --env ETCD_ADVERTISE_CLIENT_URLS=http://10.0.3.2:2379 \\ 8 --env ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379 \\ 9 --env ETCD_INITIAL_ADVERTISE_PEER_URLS=http://10.0.3.2:2380 \\ 10 --env ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster \\ 11 --env ETCD_INITIAL_CLUSTER=node1=http://10.0.3.2:2380,node2=http://10.0.3.21:2380 \\ 12 --env ETCD_INITIAL_CLUSTER_STATE=new \\ 13 bitnami/etcd:3.5.3 etcd --enable-v2 主机10.0.3.21, etcd节点名为node1 1docker run -d --name etcd --rm \\ 2--publish 2379:2379 \\ 3--publish 2380:2380 \\ 4--env ALLOW_NONE_AUTHENTICATION=yes \\ 5--env ETCD_NAME=node2 \\ 6--env ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380 \\ 7--env ETCD_ADVERTISE_CLIENT_URLS=http://10.0.3.21:2379 \\ 8--env ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379 \\ 9--env ETCD_INITIAL_ADVERTISE_PEER_URLS=http://10.0.3.21:2380 \\ 10--env ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster \\ 11--env ETCD_INITIAL_CLUSTER=node1=http://10.0.3.2:2380,node2=http://10.0.3.21:2380 \\ 12--env ETCD_INITIAL_CLUSTER_STATE=new \\ 13bitnami/etcd:3.5.3 etcd --enable-v2 查看etcd node\n1[root@ams2-10 ~]# docker exec -it etcd etcdctl member list 2796e13f38b3a972b, started, node2, http://10.0.3.21:2380, http://10.0.3.21:2379, false 3ff63796d3826f6b6, started, node1, http://10.0.3.2:2380, http://10.0.3.2:2379, false 创建overlay network\n主机10.0.3.2\n1 [root@ams2-10 SFS2X]# docker network create -d overlay etcdnet 2 f2c12e0259409c0f11c9c4a4a585753d46a80ac60c336625fd48e5322be9084e 查看网络，发现多了刚刚创建的etcdnet.而且scope是global的 1 [root@ams2-10 SFS2X]# docker network ls 2 NETWORK ID NAME DRIVER SCOPE 3 f406ad6eb59c bridge bridge local 4 f2c12e025940 etcdnet overlay global 5 097d3b78ec65 host host local 6 02d4e89d5af5 none null local 我们inspect下etcdnet信息 1 [root@ams2-10 SFS2X]# docker network inspect etcdnet 2 [ 3 { 4 \u0026#34;Name\u0026#34;: \u0026#34;etcdnet\u0026#34;, 5 \u0026#34;Id\u0026#34;: \u0026#34;f2c12e0259409c0f11c9c4a4a585753d46a80ac60c336625fd48e5322be9084e\u0026#34;, 6 \u0026#34;Created\u0026#34;: \u0026#34;2022-04-18T14:18:10.96517192Z\u0026#34;, 7 \u0026#34;Scope\u0026#34;: \u0026#34;global\u0026#34;, 8 \u0026#34;Driver\u0026#34;: \u0026#34;overlay\u0026#34;, 9 \u0026#34;EnableIPv6\u0026#34;: false, 10 \u0026#34;IPAM\u0026#34;: { 11 \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, 12 \u0026#34;Options\u0026#34;: {}, 13 \u0026#34;Config\u0026#34;: [ 14 { 15 \u0026#34;Subnet\u0026#34;: \u0026#34;10.0.0.0/24\u0026#34;, 16 \u0026#34;Gateway\u0026#34;: \u0026#34;10.0.0.1\u0026#34; 17 } 18 ] 19 }, 20 \u0026#34;Internal\u0026#34;: false, 21 \u0026#34;Attachable\u0026#34;: false, 22 \u0026#34;Containers\u0026#34;: {}, 23 \u0026#34;Options\u0026#34;: {}, 24 \u0026#34;Labels\u0026#34;: {} 25 } 26 ] 主机10.0.3.21\n查看网络，发现也有etcdnet了，也就是说一个主机创建，同集群下的主机都会自动创建 1 [root@ams2-10 ~]# docker network ls 2 NETWORK ID NAME DRIVER SCOPE 3 3ed479747a1e bridge bridge local 4 f2c12e025940 etcdnet overlay global 5 4097f7659809 host host local 6 e72e71890e1a none null local 开启一个redis服务\n主机 10.0.3.2 1 [root@ams2-10 SFS2X]# docker run -d --rm --name redis1 -h redis1 --net etcdnet 10.0.3.2:5001/base_redis 2 8769e01b7003bb42edf226c812405a2e955fb0e16fae0752c37a703efdcc2135 主机10.0.3.21 尝试也创建一个docker name为redis1的容器. 1 [root@ams2-10 ~]# docker run -d --rm --name redis1 -h redis1 --net etcdnet 10.0.3.2:5001/base_redis 2 9499adbbce469022ec1bef41415d58398fa79bc1a155316a07182f0278657a4d 3 /usr/bin/docker-current: Error response from daemon: service endpoint with name redis1 already exists. 报错了，也就是不能创建相同name的容器。我们起一个name为redis2的容器 1 [root@ams2-10 ~]# docker run -d --rm --name redis2 -h redis2 --net etcdnet 10.0.3.2:5001/base_redis 2 fea93e725e69f01ffa2e5431d470e230aa8496d8a9106a10ea738c0ff411e340 查看网络信息\n主机 10.0.3.2 运行docker network ls，多了一个docker_gwbridge，看下这个网络容器的详情信息 1 [root@ams2-10 SFS2X]# docker inspect docker_gwbridge 2 [ 3 { 4 \u0026#34;Name\u0026#34;: \u0026#34;docker_gwbridge\u0026#34;, 5 \u0026#34;Id\u0026#34;: \u0026#34;d56f9aef3da6f93cc2749efcdace3265bb29150f145041e4d736e3928fd4e363\u0026#34;, 6 \u0026#34;Created\u0026#34;: \u0026#34;2022-04-18T14:34:44.715406625Z\u0026#34;, 7 \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, 8 \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, 9 \u0026#34;EnableIPv6\u0026#34;: false, 10 \u0026#34;IPAM\u0026#34;: { 11 \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, 12 \u0026#34;Options\u0026#34;: null, 13 \u0026#34;Config\u0026#34;: [ 14 { 15 \u0026#34;Subnet\u0026#34;: \u0026#34;172.18.0.0/16\u0026#34;, 16 \u0026#34;Gateway\u0026#34;: \u0026#34;172.18.0.1\u0026#34; 17 } 18 ] 19 }, 20 \u0026#34;Internal\u0026#34;: false, 21 \u0026#34;Attachable\u0026#34;: false, 22 \u0026#34;Containers\u0026#34;: { 23 \u0026#34;d0ffff5fdc19975d8930e25438b1e03f7a960f5387dc5a577e02c89809be0d62\u0026#34;: { 24 \u0026#34;Name\u0026#34;: \u0026#34;gateway_d0ffff5fdc19\u0026#34;, 25 \u0026#34;EndpointID\u0026#34;: \u0026#34;e90ebc5c48f17d5e64bdcf442173617d0b35ed81af33a901a3ae8a75a7d11a55\u0026#34;, 26 \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:12:00:02\u0026#34;, 27 \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.18.0.2/16\u0026#34;, 28 \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; 29 } 30 }, 31 \u0026#34;Options\u0026#34;: { 32 \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;false\u0026#34;, 33 \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, 34 \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker_gwbridge\u0026#34; 35 }, 36 \u0026#34;Labels\u0026#34;: {} 37 } 38 ] 我们再看下 etcdnet详情, 可以看到给两个容器分配了ip 1 [root@ams2-10 SFS2X]# docker network inspect etcdnet 2 [ 3 { 4 \u0026#34;Name\u0026#34;: \u0026#34;etcdnet\u0026#34;, 5 \u0026#34;Id\u0026#34;: \u0026#34;f2c12e0259409c0f11c9c4a4a585753d46a80ac60c336625fd48e5322be9084e\u0026#34;, 6 \u0026#34;Created\u0026#34;: \u0026#34;2022-04-18T14:18:10.96517192Z\u0026#34;, 7 \u0026#34;Scope\u0026#34;: \u0026#34;global\u0026#34;, 8 \u0026#34;Driver\u0026#34;: \u0026#34;overlay\u0026#34;, 9 \u0026#34;EnableIPv6\u0026#34;: false, 10 \u0026#34;IPAM\u0026#34;: { 11 \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, 12 \u0026#34;Options\u0026#34;: {}, 13 \u0026#34;Config\u0026#34;: [ 14 { 15 \u0026#34;Subnet\u0026#34;: \u0026#34;10.0.0.0/24\u0026#34;, 16 \u0026#34;Gateway\u0026#34;: \u0026#34;10.0.0.1\u0026#34; 17 } 18 ] 19 }, 20 \u0026#34;Internal\u0026#34;: false, 21 \u0026#34;Attachable\u0026#34;: false, 22 \u0026#34;Containers\u0026#34;: { 23 \u0026#34;d0ffff5fdc19975d8930e25438b1e03f7a960f5387dc5a577e02c89809be0d62\u0026#34;: { 24 \u0026#34;Name\u0026#34;: \u0026#34;redis1\u0026#34;, 25 \u0026#34;EndpointID\u0026#34;: \u0026#34;fbc06b25b76eb1e4475582f0eeb51d509ca72f070891140ab482d0f54a140601\u0026#34;, 26 \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:0a:00:00:02\u0026#34;, 27 \u0026#34;IPv4Address\u0026#34;: \u0026#34;10.0.0.2/24\u0026#34;, 28 \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; 29 }, 30 \u0026#34;ep-69ecc615e82eeddbd03cd27006130607e2440d2e1025978c00267c1ba2f7544b\u0026#34;: { 31 \u0026#34;Name\u0026#34;: \u0026#34;redis2\u0026#34;, 32 \u0026#34;EndpointID\u0026#34;: \u0026#34;69ecc615e82eeddbd03cd27006130607e2440d2e1025978c00267c1ba2f7544b\u0026#34;, 33 \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:0a:00:00:03\u0026#34;, 34 \u0026#34;IPv4Address\u0026#34;: \u0026#34;10.0.0.3/24\u0026#34;, 35 \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; 36 } 37 }, 38 \u0026#34;Options\u0026#34;: {}, 39 \u0026#34;Labels\u0026#34;: {} 40 } 41 ] 进入redis1容器，ifconfig看下一下 1 [root@ams2-10 SFS2X]# docker exec -it redis1 yum install -y net-tools.x86_64 2 [root@ams2-10 SFS2X]# docker exec -it redis1 ifconfig 3 eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1450 4 inet 10.0.0.2 netmask 255.255.255.0 broadcast 0.0.0.0 5 inet6 fe80::42:aff:fe00:2 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; 6 ether 02:42:0a:00:00:02 txqueuelen 0 (Ethernet) 7 RX packets 13 bytes 1034 (1.0 KiB) 8 RX errors 0 dropped 0 overruns 0 frame 0 9 TX packets 11 bytes 894 (894.0 B) 10 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 11 12 eth1: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 13 inet 172.18.0.2 netmask 255.255.0.0 broadcast 0.0.0.0 14 inet6 fe80::42:acff:fe12:2 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; 15 ether 02:42:ac:12:00:02 txqueuelen 0 (Ethernet) 16 RX packets 7138 bytes 16361245 (15.6 MiB) 17 RX errors 0 dropped 0 overruns 0 frame 0 18 TX packets 7125 bytes 387572 (378.4 KiB) 19 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 20 21 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 22 inet 127.0.0.1 netmask 255.0.0.0 23 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; 24 loop txqueuelen 1000 (Local Loopback) 25 RX packets 56 bytes 4827 (4.7 KiB) 26 RX errors 0 dropped 0 overruns 0 frame 0 27 TX packets 56 bytes 4827 (4.7 KiB) 28 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 29 30 [root@ams2-10 SFS2X]# 测试是否ping通\n主机10.0.3.2 我们ping一下redis2 的ip 和容器名，发现都可以ping通 1 [root@ams2-10 SFS2X]# docker exec -it redis1 ping -c 5 redis2 2 PING redis2 (10.0.0.3) 56(84) bytes of data. 3 64 bytes from redis2.etcdnet (10.0.0.3): icmp_seq=1 ttl=64 time=0.325 ms 4 64 bytes from redis2.etcdnet (10.0.0.3): icmp_seq=2 ttl=64 time=0.557 ms 5 64 bytes from redis2.etcdnet (10.0.0.3): icmp_seq=3 ttl=64 time=0.446 ms 6 64 bytes from redis2.etcdnet (10.0.0.3): icmp_seq=4 ttl=64 time=0.430 ms 7 64 bytes from redis2.etcdnet (10.0.0.3): icmp_seq=5 ttl=64 time=0.578 ms 8 --- redis2 ping statistics --- 9 5 packets transmitted, 5 received, 0% packet loss, time 3999ms 10 rtt min/avg/max/mdev = 0.325/0.467/0.578/0.093 ms 尝试连接redis2的服务，看到没问题 1 # 可以正常链接 2 [root@ams2-10 SFS2X]# docker exec -it redis1 /home/elex/redis/bin/redis-cli -h redis2 set m1 dd 3 OK 4 [root@ams2-10 SFS2X]# docker exec -it redis1 /home/elex/redis/bin/redis-cli -h redis2 get m1 5 \u0026#34;dd\u0026#34; 主机10.0.3.21， redis2 同样可以通过ip和容器名 ping通 ps\n查看etcd版本号 curl http://10.0.3.2:2379/versoin ","permalink":"https://omgkill.github.io/post/docker/docker-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E5%AE%B9%E5%99%A8%E9%97%B4%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/","tags":["docker","网络"],"title":"Docker 跨主机容器间网络通信"},{"categories":["blob"],"contents":" sixdian Notes Hugo 使用 Jane 主题常用的一些配置 Published on: April 21, 2022 | Reading Time: 4 min | Last Modified: April 21, 2022\nhugojane配置\nHugo 下的 Jane 主题是基于 even 主题进行的重新改造，主要有以下特色：\n响应式设计 多国语言支持 支持多个 Shortcode 单独设计的标签页和分类页 支持社交网站链接 优秀的分页、目录、注脚样式 使用更快的 Chroma 代码高亮 自定义 css、js、head 支持子目录 搜索引擎优化 初始化的样式展示的元素繁多可能不太符合每个人的实际需求，我们需要对需要显示的内容样式进行修改来增强站点整体的美感。下面就介绍如何改靠自己的独特主题：\n默认情况下生成的站点部署后我我们会发现在手机上点按菜单位置无效，无法正常显示下拉菜单。我们可以按照下面的方法让菜单能在移动端正常显示。\nJane 主题移动端无法显示下拉菜单的解决方法 themes\\jane\\layouts\\partials\\scripts.html #根据路径找到这个文件,删除其中的 integrity 属性\n1\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;{{ $secureJS.RelPermalink }}\u0026#34; integrity=\u0026#34;{{ $secureJS.Data.Integrity }}\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 另外现在人们通过 RSS 客户端阅读的方式已经越来越少，Jane 主题内的 RSS 订阅图标我个人觉得太过多余不符合我追求简洁的审美观，所以也要对它进行隐藏处理。具体处理方法如下：\nJane 主题底部 RSS 订阅图标删除 ./layouts/partials/social_links.html #在 themes 文件夹下根据路径找到这个文件，删除以下代码\n1\u0026lt;!-- 2{{/* RSS icon */}} 3{{ with .Site.GetPage \u0026#34;home\u0026#34; -}} 4 {{- with .OutputFormats.Get \u0026#34;RSS\u0026#34; -}} 5 \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; rel=\u0026#34;noopener {{ .Rel }}\u0026#34; type=\u0026#34;{{ .MediaType.Type }}\u0026#34; 6 class=\u0026#34;iconfont\u0026#34; title=\u0026#34;rss\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; 7 {{ partial \u0026#34;svg/rss.svg\u0026#34; }} 8 \u0026lt;/a\u0026gt; 9 {{ end -}} 10{{- end -}} 11--\u0026gt; 其它需要设置的细节内容过多，而且过于简单，下面统一做个总结：\nJane 主题配置文件详细解释 1# 基础设置 2#------------------------------------------------------------------- 3baseURL = \u0026#34;https://sixdian.com/\u0026#34; # 博客部署网址 4title = \u0026#34;六点随记\u0026#34; # 网站名称 5enableRobotsTXT = true # 是否支持Robots协议 6enableEmoji = true # 是否支持Emoji表情符号 7theme = \u0026#34;jane\u0026#34; # 选用jane主题 8hasCJKLanguage = true # 自动检测是否包含 中文\\日文\\韩文 9paginate = 10 # 首页每页显示的文章数目 10rssLimit = 20 # 限制 Rss 文章输出数量 11disqusShortname = \u0026#34;\u0026#34; # disqus_shortname 12googleAnalytics = \u0026#34;\u0026#34; # 配置google统计 13copyright = \u0026#34;\u0026#34; # 默认为下面配置的author.name， 14 15# 关于语言 16defaultContentLanguage = \u0026#34;zh-cn\u0026#34; # 默认博客语言环境 17[languages.zh-cn] # 语言支持 18 languageCode = \u0026#34;zh-cn\u0026#34; 19 20# 关于语法高亮，具体使用可查看https://gohugo.io/content-management/syntax-highlighting/ 21PygmentsCodeFences = true # Enable syntax highlighting with GitHub flavoured code fences 22PygmentsUseClasses = true # Use CSS classes to format highlighted code 23PygmentsCodefencesGuessSyntax = true # 24PygmentsOptions = \u0026#34;linenos=table\u0026#34; # 开启显示行号 25 26[author] # 作者名称 27 name = \u0026#34;sixdian\u0026#34; 28[sitemap] # 站点地图 29 changefreq = \u0026#34;weekly\u0026#34; 30 priority = 0.5 31 filename = \u0026#34;sitemap.xml\u0026#34; 32#------------------------------------------------------------------- 33 34#菜单设置 35#------------------------------------------------------------------- 36[[menu.main]] 37 name = \u0026#34;主页\u0026#34; 38 weight = 10 39 identifier = \u0026#34;home\u0026#34; 40 url = \u0026#34;/\u0026#34; 41[[menu.main]] 42 name = \u0026#34;归档\u0026#34; 43 weight = 20 44 identifier = \u0026#34;archives\u0026#34; 45 url = \u0026#34;/post/\u0026#34; 46[[menu.main]] 47 name = \u0026#34;分类\u0026#34; 48 weight = 30 49 identifier = \u0026#34;categories\u0026#34; 50 url = \u0026#34;/categories/\u0026#34; 51[[menu.main]] 52 name = \u0026#34;标签\u0026#34; 53 weight = 40 54 identifier = \u0026#34;tags\u0026#34; 55 url = \u0026#34;/tags/\u0026#34; 56[[menu.main]] 57 name = \u0026#34;关于\u0026#34; 58 weight = 50 59 identifier = \u0026#34;about\u0026#34; 60 url = \u0026#34;/about/\u0026#34; 61[[menu.main]] 62 name = \u0026#34;友链\u0026#34; 63 weight = 60 64 identifier = \u0026#34;links\u0026#34; 65 url = \u0026#34;/links/\u0026#34; 66[[menu.main]] 67 name = \u0026#34;订阅\u0026#34; 68 weight = 70 69 identifier = \u0026#34;feed\u0026#34; 70 url = \u0026#34;/index.xml\u0026#34; 71#------------------------------------------------------------------- 72 73#其他参数设置 74#------------------------------------------------------------------- 75[params] 76 since = \u0026#34;2022\u0026#34; # 站点建立时间 77 homeFullContent = false # 主页是否显示全部文章内容 78 rssFullContent = true # if false, Rss feed instead of the summary 79 logoTitle = \u0026#34;六点随笔\u0026#34; # 博客标题，默认值是上面设置的title，也就是网址名称 80 keywords = [\u0026#34;Hugo\u0026#34;, \u0026#34;linux\u0026#34;, \u0026#34;emacs\u0026#34;, \u0026#34;CPU\u0026#34;] # 关键字 81 description = \u0026#34;\u0026#34; # 网页描述 82 archive-paginate = 30 # 归档、标签、分类每页显示的文章数目 83 dateFormatToUse = \u0026#34;2006-01-02\u0026#34; # 日期显示格式，查看可支持的格式见https://gohugo.io/functions/format/ 84 moreMeta = true # 是否显示字数统计与阅读时间 85 showMenuLanguageChooser = true # 显示语言选择开关 86 showAuthorInfo = true # 文章末尾显示作者信息 87 88 # 一些全局开关，这些是默认值，也可以在每一篇内容的 front matter 中对单篇内容关闭或开启某些功能，在 archetypes/default.md 查看更多信息。 89 toc = true # 是否开启目录 90 photoswipe = true # 是否启用PhotoSwipe（图片可点击） 91 bootcdn = true # 是否使用bootcdn 92 mathjax = false # 是否使用mathjax（数学公式） 93 contentCopyright = \u0026#39;六点创作，转载请注明出处！\u0026#39; # 版权声明 94 95 customCSS = [] # if [\u0026#39;custom.css\u0026#39;], load \u0026#39;/static/css/custom.css\u0026#39; file 96 customJS = [] # if [\u0026#39;custom.js\u0026#39;], load \u0026#39;/static/js/custom.js\u0026#39; file 97#------------------------------------------------------------------- 98 99# CDN设置 100#------------------------------------------------------------------- 101 [params.publicCDN] # load these files from public cdn 102 enable = true 103 jquery = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js\u0026#34; integrity=\u0026#34;sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; 104 slideout = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js\u0026#34; integrity=\u0026#34;sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; 105 gitmentJS = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; 106 gitmentCSS = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; 107 photoswipe = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.js\u0026#34; integrity=\u0026#34;sha256-AC9ChpELidrhGHX23ZU53vmRdz3FhKaN9E28+BbcWBw=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; 108 photoswipeUI = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js\u0026#34; integrity=\u0026#34;sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; 109 photoswipeCSS = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css\u0026#34; integrity=\u0026#34;sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; 110 photoswipeSKIN = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css\u0026#34; integrity=\u0026#34;sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; 111#------------------------------------------------------------------- 112 113# 下面是关于评论系统，更新显示commit内容，谷歌搜索，文章打赏，访问数据统计等等 114#------------------------------------------------------------------- 115 [params.utteranc] # utteranc is a comment system based on GitHub issues. see https://utteranc.es 116 enable = false 117 repo = \u0026#34;xianmin/comments-for-hugo-theme-jane\u0026#34; # The repo to store comments 118 issueTerm = \u0026#34;pathname\u0026#34; 119 120 [params.gitment] # Gitment is a comment system based on GitHub issues. see https://github.com/imsun/gitment 121 owner = \u0026#34;\u0026#34; # Your GitHub ID 122 repo = \u0026#34;\u0026#34; # The repo to store comments 123 clientId = \u0026#34;\u0026#34; # Your client ID 124 clientSecret = \u0026#34;\u0026#34; # Your client secret 125 126 [params.livere] #LiveRe comment. see https://www.livere.com/ 127 uid = \u0026#34;\u0026#34; 128 129 [params.reward] # 文章打赏 130 enable = false 131 wechat = \u0026#34;/path/to/your/wechat-qr-code.png\u0026#34; # 微信二维码 132 alipay = \u0026#34;/path/to/your/alipay-qr-code.png\u0026#34; # 支付宝二维码 133 134 [params.counter.busuanzi] # a Chinese visitor counter # 卜算子计数器 135 enable = false 136 137 [params.counter.leancloud] # Chinese leancloud visitor counter # leancloud 计数器 138 enable = false 139 appId = \u0026#34;\u0026#34; 140 appKey = \u0026#34;\u0026#34; 141 142 [params.commentCount.disqus] # show counts of comments for Disqus 143 enable = false 144 145 [params.search.google] # google custom search, see https://cse.google.com 146 enable = false 147 id = \u0026#34;002186711602136249422:q1gkomof_em\u0026#34; 148 title = \u0026#34;Search\u0026#34; 149 150 [params.gitInfo] 151 gitRepo = \u0026#34;https://github.com/xianmin/xianmin.org\u0026#34; 152 showCommitMessage = false 153#------------------------------------------------------------------- 154 155#社交链接 156#------------------------------------------------------------------- 157# [params.social] 158# a-email = \u0026#34;mailto:your@email.com\u0026#34; 159# b-stack-overflow = \u0026#34;http://localhost:1313\u0026#34; 160# c-twitter = \u0026#34;http://localhost:1313\u0026#34; 161# d-facebook = \u0026#34;http://localhost:1313\u0026#34; 162# e-linkedin = \u0026#34;http://localhost:1313\u0026#34; 163# f-google = \u0026#34;http://localhost:1313\u0026#34; 164# g-github = \u0026#34;http://localhost:1313\u0026#34; 165# h-weibo = \u0026#34;http://localhost:1313\u0026#34; 166# i-zhihu = \u0026#34;http://localhost:1313\u0026#34; 167# j-douban = \u0026#34;http://localhost:1313\u0026#34; 168# k-pocket = \u0026#34;http://localhost:1313\u0026#34; 169# l-tumblr = \u0026#34;http://localhost:1313\u0026#34; 170# m-instagram = \u0026#34;http://localhost:1313\u0026#34; 171# n-gitlab = \u0026#34;http://localhost:1313\u0026#34; 172# o-goodreads = \u0026#34;http://localhost:1313\u0026#34; 173# p-coding = \u0026#34;http://localhost:1313\u0026#34; 174# q-bilibili = \u0026#34;http://localhost:1313\u0026#34; 175# r-codeforces = \u0026#34;http://localhost:1313\u0026#34; 176# s-mastodon = \u0026#34;http://localhost:1313\u0026#34; 177#------------------------------------------------------------------- © 2022-2023 🚴 sixdian\n","permalink":"https://omgkill.github.io/post/knowledgesite/jane/","tags":["hugo","blob"],"title":"Hugo 使用 Jane 主题常用的一些配置"},{"categories":["docker"],"contents":" 安装docker\nyum install -y docker 创建网络\ndocker network create test_net 创建redis1\ndocker run -d \u0026ndash;rm \u0026ndash;name redis1 -h redis1 \u0026ndash;net test_net 10.0.3.2:5001/base_redis 创建redis2\ndocker run -d \u0026ndash;rm \u0026ndash;name redis2 -h redis2 \u0026ndash;net test_net 10.0.3.2:5001/base_redis 测试\ndocker exec -it redis1 ping -c 3 redis2 ","permalink":"https://omgkill.github.io/post/docker/docker%E5%8D%95%E6%9C%BA%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BF%9E/","tags":["docker","网络"],"title":"Docker单机容器互连"},{"categories":null,"contents":"#Docker 跨主机容器通信实践\nDockerOverlay网络\nOverlay是一种覆盖在主机上的虚拟网络，我理解的overlay他需要借助插件或工具完成对数据的保存和转发。我们这里使用etcd来完成overlay的跨主机容器通信 本文以两台机器为例，ip分配是 10.0.3.2 与 10.0.3.21\n检查两台机器hostname是否不同，如果相同需要修改。不然无法联通\n两台机器安装docker\nyum install -y docker 修改docker配置,指定外部存储使用etcd，/etc/docker/daemon.json 加如下数据\n主机10.0.3.2 \u0026ldquo;cluster-store\u0026rdquo;:\u0026ldquo;etcd://10.0.3.2:2379\u0026rdquo;,\u0026ldquo;cluster-advertise\u0026rdquo;:\u0026ldquo;10.0.3.2:2375\u0026rdquo; 主机10.0.3.21 \u0026ldquo;cluster-store\u0026rdquo;:\u0026ldquo;etcd://10.0.3.21:2379\u0026rdquo;,\u0026ldquo;cluster-advertise\u0026rdquo;:\u0026ldquo;10.0.3.21:2375\u0026rdquo; 重启docker\nsystemctl daemon-reload systemctl restart docker 启动etcd\n主机10.0.3.2, etcd节点名为node1 1 docker run -d --name etcd --rm \\ 2 --publish 2379:2379 \\ 3 --publish 2380:2380 \\ 4 --env ALLOW_NONE_AUTHENTICATION=yes \\ 5 --env ETCD_NAME=node1 \\ 6 --env ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380 \\ 7 --env ETCD_ADVERTISE_CLIENT_URLS=http://10.0.3.2:2379 \\ 8 --env ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379 \\ 9 --env ETCD_INITIAL_ADVERTISE_PEER_URLS=http://10.0.3.2:2380 \\ 10 --env ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster \\ 11 --env ETCD_INITIAL_CLUSTER=node1=http://10.0.3.2:2380,node2=http://10.0.3.21:2380 \\ 12 --env ETCD_INITIAL_CLUSTER_STATE=new \\ 13 bitnami/etcd:3.5.3 etcd --enable-v2 主机10.0.3.21, etcd节点名为node1 1docker run -d --name etcd --rm \\ 2--publish 2379:2379 \\ 3--publish 2380:2380 \\ 4--env ALLOW_NONE_AUTHENTICATION=yes \\ 5--env ETCD_NAME=node2 \\ 6--env ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380 \\ 7--env ETCD_ADVERTISE_CLIENT_URLS=http://10.0.3.21:2379 \\ 8--env ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379 \\ 9--env ETCD_INITIAL_ADVERTISE_PEER_URLS=http://10.0.3.21:2380 \\ 10--env ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster \\ 11--env ETCD_INITIAL_CLUSTER=node1=http://10.0.3.2:2380,node2=http://10.0.3.21:2380 \\ 12--env ETCD_INITIAL_CLUSTER_STATE=new \\ 13bitnami/etcd:3.5.3 etcd --enable-v2 查看etcd node\n1[root@ams2-10 ~]# docker exec -it etcd etcdctl member list 2796e13f38b3a972b, started, node2, http://10.0.3.21:2380, http://10.0.3.21:2379, false 3ff63796d3826f6b6, started, node1, http://10.0.3.2:2380, http://10.0.3.2:2379, false 创建overlay network\n主机10.0.3.2\n1 [root@ams2-10 SFS2X]# docker network create -d overlay etcdnet 2 f2c12e0259409c0f11c9c4a4a585753d46a80ac60c336625fd48e5322be9084e 查看网络，发现多了刚刚创建的etcdnet.而且scope是global的 1 [root@ams2-10 SFS2X]# docker network ls 2 NETWORK ID NAME DRIVER SCOPE 3 f406ad6eb59c bridge bridge local 4 f2c12e025940 etcdnet overlay global 5 097d3b78ec65 host host local 6 02d4e89d5af5 none null local 我们inspect下etcdnet信息 1 [root@ams2-10 SFS2X]# docker network inspect etcdnet 2 [ 3 { 4 \u0026#34;Name\u0026#34;: \u0026#34;etcdnet\u0026#34;, 5 \u0026#34;Id\u0026#34;: \u0026#34;f2c12e0259409c0f11c9c4a4a585753d46a80ac60c336625fd48e5322be9084e\u0026#34;, 6 \u0026#34;Created\u0026#34;: \u0026#34;2022-04-18T14:18:10.96517192Z\u0026#34;, 7 \u0026#34;Scope\u0026#34;: \u0026#34;global\u0026#34;, 8 \u0026#34;Driver\u0026#34;: \u0026#34;overlay\u0026#34;, 9 \u0026#34;EnableIPv6\u0026#34;: false, 10 \u0026#34;IPAM\u0026#34;: { 11 \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, 12 \u0026#34;Options\u0026#34;: {}, 13 \u0026#34;Config\u0026#34;: [ 14 { 15 \u0026#34;Subnet\u0026#34;: \u0026#34;10.0.0.0/24\u0026#34;, 16 \u0026#34;Gateway\u0026#34;: \u0026#34;10.0.0.1\u0026#34; 17 } 18 ] 19 }, 20 \u0026#34;Internal\u0026#34;: false, 21 \u0026#34;Attachable\u0026#34;: false, 22 \u0026#34;Containers\u0026#34;: {}, 23 \u0026#34;Options\u0026#34;: {}, 24 \u0026#34;Labels\u0026#34;: {} 25 } 26 ] 主机10.0.3.21\n查看网络，发现也有etcdnet了，也就是说一个主机创建，同集群下的主机都会自动创建 1 [root@ams2-10 ~]# docker network ls 2 NETWORK ID NAME DRIVER SCOPE 3 3ed479747a1e bridge bridge local 4 f2c12e025940 etcdnet overlay global 5 4097f7659809 host host local 6 e72e71890e1a none null local 开启一个redis服务\n主机 10.0.3.2 1 [root@ams2-10 SFS2X]# docker run -d --rm --name redis1 -h redis1 --net etcdnet 10.0.3.2:5001/base_redis 2 8769e01b7003bb42edf226c812405a2e955fb0e16fae0752c37a703efdcc2135 主机10.0.3.21 尝试也创建一个docker name为redis1的容器. 1 [root@ams2-10 ~]# docker run -d --rm --name redis1 -h redis1 --net etcdnet 10.0.3.2:5001/base_redis 2 9499adbbce469022ec1bef41415d58398fa79bc1a155316a07182f0278657a4d 3 /usr/bin/docker-current: Error response from daemon: service endpoint with name redis1 already exists. 报错了，也就是不能创建相同name的容器。我们起一个name为redis2的容器 1 [root@ams2-10 ~]# docker run -d --rm --name redis2 -h redis2 --net etcdnet 10.0.3.2:5001/base_redis 2 fea93e725e69f01ffa2e5431d470e230aa8496d8a9106a10ea738c0ff411e340 查看网络信息\n主机 10.0.3.2 运行docker network ls，多了一个docker_gwbridge，看下这个网络容器的详情信息 1 [root@ams2-10 SFS2X]# docker inspect docker_gwbridge 2 [ 3 { 4 \u0026#34;Name\u0026#34;: \u0026#34;docker_gwbridge\u0026#34;, 5 \u0026#34;Id\u0026#34;: \u0026#34;d56f9aef3da6f93cc2749efcdace3265bb29150f145041e4d736e3928fd4e363\u0026#34;, 6 \u0026#34;Created\u0026#34;: \u0026#34;2022-04-18T14:34:44.715406625Z\u0026#34;, 7 \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, 8 \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, 9 \u0026#34;EnableIPv6\u0026#34;: false, 10 \u0026#34;IPAM\u0026#34;: { 11 \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, 12 \u0026#34;Options\u0026#34;: null, 13 \u0026#34;Config\u0026#34;: [ 14 { 15 \u0026#34;Subnet\u0026#34;: \u0026#34;172.18.0.0/16\u0026#34;, 16 \u0026#34;Gateway\u0026#34;: \u0026#34;172.18.0.1\u0026#34; 17 } 18 ] 19 }, 20 \u0026#34;Internal\u0026#34;: false, 21 \u0026#34;Attachable\u0026#34;: false, 22 \u0026#34;Containers\u0026#34;: { 23 \u0026#34;d0ffff5fdc19975d8930e25438b1e03f7a960f5387dc5a577e02c89809be0d62\u0026#34;: { 24 \u0026#34;Name\u0026#34;: \u0026#34;gateway_d0ffff5fdc19\u0026#34;, 25 \u0026#34;EndpointID\u0026#34;: \u0026#34;e90ebc5c48f17d5e64bdcf442173617d0b35ed81af33a901a3ae8a75a7d11a55\u0026#34;, 26 \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:12:00:02\u0026#34;, 27 \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.18.0.2/16\u0026#34;, 28 \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; 29 } 30 }, 31 \u0026#34;Options\u0026#34;: { 32 \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;false\u0026#34;, 33 \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, 34 \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker_gwbridge\u0026#34; 35 }, 36 \u0026#34;Labels\u0026#34;: {} 37 } 38 ] 我们再看下 etcdnet详情, 可以看到给两个容器分配了ip 1 [root@ams2-10 SFS2X]# docker network inspect etcdnet 2 [ 3 { 4 \u0026#34;Name\u0026#34;: \u0026#34;etcdnet\u0026#34;, 5 \u0026#34;Id\u0026#34;: \u0026#34;f2c12e0259409c0f11c9c4a4a585753d46a80ac60c336625fd48e5322be9084e\u0026#34;, 6 \u0026#34;Created\u0026#34;: \u0026#34;2022-04-18T14:18:10.96517192Z\u0026#34;, 7 \u0026#34;Scope\u0026#34;: \u0026#34;global\u0026#34;, 8 \u0026#34;Driver\u0026#34;: \u0026#34;overlay\u0026#34;, 9 \u0026#34;EnableIPv6\u0026#34;: false, 10 \u0026#34;IPAM\u0026#34;: { 11 \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, 12 \u0026#34;Options\u0026#34;: {}, 13 \u0026#34;Config\u0026#34;: [ 14 { 15 \u0026#34;Subnet\u0026#34;: \u0026#34;10.0.0.0/24\u0026#34;, 16 \u0026#34;Gateway\u0026#34;: \u0026#34;10.0.0.1\u0026#34; 17 } 18 ] 19 }, 20 \u0026#34;Internal\u0026#34;: false, 21 \u0026#34;Attachable\u0026#34;: false, 22 \u0026#34;Containers\u0026#34;: { 23 \u0026#34;d0ffff5fdc19975d8930e25438b1e03f7a960f5387dc5a577e02c89809be0d62\u0026#34;: { 24 \u0026#34;Name\u0026#34;: \u0026#34;redis1\u0026#34;, 25 \u0026#34;EndpointID\u0026#34;: \u0026#34;fbc06b25b76eb1e4475582f0eeb51d509ca72f070891140ab482d0f54a140601\u0026#34;, 26 \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:0a:00:00:02\u0026#34;, 27 \u0026#34;IPv4Address\u0026#34;: \u0026#34;10.0.0.2/24\u0026#34;, 28 \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; 29 }, 30 \u0026#34;ep-69ecc615e82eeddbd03cd27006130607e2440d2e1025978c00267c1ba2f7544b\u0026#34;: { 31 \u0026#34;Name\u0026#34;: \u0026#34;redis2\u0026#34;, 32 \u0026#34;EndpointID\u0026#34;: \u0026#34;69ecc615e82eeddbd03cd27006130607e2440d2e1025978c00267c1ba2f7544b\u0026#34;, 33 \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:0a:00:00:03\u0026#34;, 34 \u0026#34;IPv4Address\u0026#34;: \u0026#34;10.0.0.3/24\u0026#34;, 35 \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; 36 } 37 }, 38 \u0026#34;Options\u0026#34;: {}, 39 \u0026#34;Labels\u0026#34;: {} 40 } 41 ] 进入redis1容器，ifconfig看下一下 1 [root@ams2-10 SFS2X]# docker exec -it redis1 yum install -y net-tools.x86_64 2 [root@ams2-10 SFS2X]# docker exec -it redis1 ifconfig 3 eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1450 4 inet 10.0.0.2 netmask 255.255.255.0 broadcast 0.0.0.0 5 inet6 fe80::42:aff:fe00:2 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; 6 ether 02:42:0a:00:00:02 txqueuelen 0 (Ethernet) 7 RX packets 13 bytes 1034 (1.0 KiB) 8 RX errors 0 dropped 0 overruns 0 frame 0 9 TX packets 11 bytes 894 (894.0 B) 10 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 11 12 eth1: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 13 inet 172.18.0.2 netmask 255.255.0.0 broadcast 0.0.0.0 14 inet6 fe80::42:acff:fe12:2 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; 15 ether 02:42:ac:12:00:02 txqueuelen 0 (Ethernet) 16 RX packets 7138 bytes 16361245 (15.6 MiB) 17 RX errors 0 dropped 0 overruns 0 frame 0 18 TX packets 7125 bytes 387572 (378.4 KiB) 19 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 20 21 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 22 inet 127.0.0.1 netmask 255.0.0.0 23 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; 24 loop txqueuelen 1000 (Local Loopback) 25 RX packets 56 bytes 4827 (4.7 KiB) 26 RX errors 0 dropped 0 overruns 0 frame 0 27 TX packets 56 bytes 4827 (4.7 KiB) 28 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 29 30 [root@ams2-10 SFS2X]# 测试是否ping通\n主机10.0.3.2 我们ping一下redis2 的ip 和容器名，发现都可以ping通 1 [root@ams2-10 SFS2X]# docker exec -it redis1 ping -c 5 redis2 2 PING redis2 (10.0.0.3) 56(84) bytes of data. 3 64 bytes from redis2.etcdnet (10.0.0.3): icmp_seq=1 ttl=64 time=0.325 ms 4 64 bytes from redis2.etcdnet (10.0.0.3): icmp_seq=2 ttl=64 time=0.557 ms 5 64 bytes from redis2.etcdnet (10.0.0.3): icmp_seq=3 ttl=64 time=0.446 ms 6 64 bytes from redis2.etcdnet (10.0.0.3): icmp_seq=4 ttl=64 time=0.430 ms 7 64 bytes from redis2.etcdnet (10.0.0.3): icmp_seq=5 ttl=64 time=0.578 ms 8 --- redis2 ping statistics --- 9 5 packets transmitted, 5 received, 0% packet loss, time 3999ms 10 rtt min/avg/max/mdev = 0.325/0.467/0.578/0.093 ms 尝试连接redis2的服务，看到没问题 1 # 可以正常链接 2 [root@ams2-10 SFS2X]# docker exec -it redis1 /home/elex/redis/bin/redis-cli -h redis2 set m1 dd 3 OK 4 [root@ams2-10 SFS2X]# docker exec -it redis1 /home/elex/redis/bin/redis-cli -h redis2 get m1 5 \u0026#34;dd\u0026#34; 主机10.0.3.21， redis2 同样可以通过ip和容器名 ping通 ps\n查看etcd版本号 curl http://10.0.3.2:2379/versoin ","permalink":"https://omgkill.github.io/bak/docker/docker-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E5%AE%B9%E5%99%A8%E9%97%B4%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/","tags":null,"title":""},{"categories":null,"contents":" 安装docker\nyum install -y docker 创建网络\ndocker network create test_net 创建redis1\ndocker run -d \u0026ndash;rm \u0026ndash;name redis1 -h redis1 \u0026ndash;net test_net 10.0.3.2:5001/base_redis 创建redis2\ndocker run -d \u0026ndash;rm \u0026ndash;name redis2 -h redis2 \u0026ndash;net test_net 10.0.3.2:5001/base_redis 测试\ndocker exec -it redis1 ping -c 3 redis2 ","permalink":"https://omgkill.github.io/bak/docker/docker%E5%8D%95%E6%9C%BA%E5%AE%B9%E5%99%A8%E4%BA%92%E8%BF%9E/","tags":null,"title":""},{"categories":null,"contents":"ams2 压测服game服务容器化 由于压测都是找空闲的机器来测试，所以每次压测都要重新部署环境，为了简化流程，想通过docker简化操作\n参考lost私服做的修改\nlost私服:http://confluence.super-chameleon.com:8093/pages/viewpage.action?pageId=75476077 文件路径\nhttp://svn.super-chameleon.com:8822/svn/AMS_TD/Source/trunk/Server/Tools/Ops/ds 使用jenkins构建docker镜像\njenkins地址：http://10.0.3.2:7005/ 使用nexus3作为docker镜像仓库\n仓库地址：http://10.0.3.2:8082/ docker 管理界面\n地址：http://10.0.3.2:9000/ 关于base的构建\nbase的意思是搭建一个基础环境\n包含cetos7、jdk安装、mysql安装、redis安装、ssh安装\njenkins构建base\n进入jenkins界面，点击build_ams2_base\n​\n再点击立即构建，就会自动编译，并编译推送到仓库\njenkins配置：http://svn.super-chameleon.com:8822/svn/AMS_TD/Source/trunk/Server/Tools/Ops/ds/jenkins/build_ams2_base.jenkins\ndockerfile以及其他文件：http://svn.super-chameleon.com:8822/svn/AMS_TD/Source/trunk/Server/Tools/Ops/ds/docker/base\n关于ams2的构建\n这个就是真正构建game服务 包含redis启动、mysql启动、mysql数据导入、game部署文件、game启动 jenkins构建base 进入jenkins界面，点击build_ams2_ds 再点击立即构建，就会自动编译，并编译推送到仓库 jenkins配置：http://svn.super-chameleon.com:8822/svn/AMS_TD/Source/trunk/Server/Tools/Ops/ds/jenkins/build_ams2_ds.jenkins dockerfile以及其他文件：http://svn.super-chameleon.com:8822/svn/AMS_TD/Source/trunk/Server/Tools/Ops/ds/docker/ams2 说一下build_ams2_base 这个任务如何创建的。build_ams2_ds同理\n点击新建任务， 输入任务名字，点击流水线，再点击报错 填写描述，点击不允许并发构建 按照如下配置，Credentials是svn的账号密码 还有一个脚本路径，这个是相对路径。相对于svn down的目录 点击保存就好了 ","permalink":"https://omgkill.github.io/bak/docker/game%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96/","tags":null,"title":""},{"categories":null,"contents":" windows系统要求 系统是专业版 系统版本号Windows10 2018 April（Windows 1803）及以上版本 安装需要的功能 打开控制面板 -\u0026gt; 搜索启动或关闭Windows功能 -\u0026gt; 选择以下功能 -\u0026gt; 点击确定 -\u0026gt; 安装 -\u0026gt; 重启 更新wsl2 下载安装 https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi 在管理员下执行命令 wsl \u0026ndash;set-default-version 2 需要更多的设置参考 https://docs.microsoft.com/zh-cn/windows/wsl/setup/environment https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/gui-apps https://docs.microsoft.com/en-us/windows/wsl/install-manual 更新wsl2内核 - 在管理员下执行命令 更新：wsl \u0026ndash;update 重启：wsl \u0026ndash;shutdown 安装centos7子系统 下载地址，对应centos7 https://github.com/wsldl-pg/CentWSL/releases/ 解压到指定目录 点击centos7.exe,会自动安装 完成后，我们查看当前子系统 命令行下执行：wsl -l -v 设置centos7为默认子系统 wslconfig /s CentOS7 wsl 进入centos7,查看系统信息 cat /etc/redhat-release 目前为止，windows下linux子系统已安装完成，接下连安装docker docker 下载地址 https://www.docker.com/get-started/ 选择wsl2安装 安装完成后，需要改的配置 加仓库地址 docker也安装完成 启动docker命令 需要把服id（SERVER_ID）改为自己的服id 1docker run -d --privileged --rm --name game -h game -v C:\\Users\\Administrator\\Desktop\\td\\ClashOfKingProject:/home/ams2/ClashOfKingProject --env SERVER_ID=11 -p 8080:8080 -p 8088:8088 -p 8788:8788 -v redis_data:/home/elex/redis/data 10.0.3.2:5001/developer/game 兼容的模拟器 下载地址 https://www.bluestacks.com/download.html ps：windows 下 docker与wsl占用内存太高了，不建议用 ","permalink":"https://omgkill.github.io/bak/docker/windows%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8docker%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95%E6%9C%8D/","tags":null,"title":""},{"categories":null,"contents":" gm服部署nexus3，这个用于docker image 仓库。 参考：http://confluence.super-chameleon.com:8093/pages/viewpage.action?pageId=75479441 gm服部署jenkins 参考：http://confluence.super-chameleon.com:8093/pages/viewpage.action?pageId=75479445 需要安装docker plugin 插件管理中安装Docker, 系统管理-\u0026gt;插件管理-\u0026gt; 可选插件-\u0026gt;搜索docker 配置docker镜像仓库地址和密钥，路径：系统管理-\u0026gt;系统配置-\u0026gt; Declarative Pipeline (Docker) 安装gradle plugin 配置gradle，名字：gradle564，版本：Gradle 5.6.4，路径：系统管理-\u0026gt;全局工具配置-\u0026gt; Gradle jenkins配置 参考：http://confluence.super-chameleon.com:8093/pages/viewpage.action?pageId=96209340 构建ams2-base 和 ams2-ds svn checkout 脚本 svn地址：http://svn.super-chameleon.com:8822/svn/AMS_TD/Source/trunk/Server/Tools/Ops/ds/deploy_stressing 进入deploy_stressing文件夹 执行脚本， 默认启动8001服 python deploy_stressing_server.py -g \u0026lt;game服内网ip\u0026gt; -d \u0026lt;mysql与clusterRedis服内网ip\u0026gt; -n \u0026lt;docker镜像仓库所在服内网ip\u0026gt; 如果要重启game服，要多加一个参数：-r python deploy_stressing_server.py -g \u0026lt;game服内网ip\u0026gt; -d \u0026lt;mysql与clusterRedis服内网ip\u0026gt; -n \u0026lt;docker镜像仓库所在服内网ip\u0026gt; -r true 脚本支持重复执行，如果脚本中途执行失败，可以重复执行 docker储存到宿主机的数据 mysql的数据存储地址，在宿主机的:/home/docker/docker/volume/stress_db_mysql redis的数据存储地址，在宿主机：/home/docker/docker/volume/stress_db_redis game log的数据存储地址，在宿主机：/home/docker/docker/volume/stress_game_log 示例 python .\\deploy_stressing_server.py -g 10.0.3.203 -d 10.0.3.21 -n 10.0.3.2 ##脚本说明\n脚本需要两台服务器。 一个台部署game与local redis，一台部署mysql与cluster redis 两台机器容器如何互联，参考：http://confluence.super-chameleon.com:8093/pages/viewpage.action?pageId=96209514 如果要删除所有docker数据，执行一下命令 yum remove -y docker* ##报错解决\n1报错解决 2 3[root@server2002 home]# docker network rm docker_gwbridge 4Error response from daemon: network docker_gwbridge has active endpoints 5 6 7 8 9[root@server2002 home]# docker network inspect docker_gwbridge 10[ 11 { 12 \u0026#34;Name\u0026#34;: \u0026#34;docker_gwbridge\u0026#34;, 13 \u0026#34;Id\u0026#34;: \u0026#34;0eecc7be54a618d305be26b9081998437529e5dace05c71b538da63611509cc3\u0026#34;, 14 \u0026#34;Created\u0026#34;: \u0026#34;2022-04-24T07:35:29.709419174Z\u0026#34;, 15 \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, 16 \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, 17 \u0026#34;EnableIPv6\u0026#34;: false, 18 \u0026#34;IPAM\u0026#34;: { 19 \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, 20 \u0026#34;Options\u0026#34;: null, 21 \u0026#34;Config\u0026#34;: [ 22 { 23 \u0026#34;Subnet\u0026#34;: \u0026#34;172.19.0.0/16\u0026#34;, 24 \u0026#34;Gateway\u0026#34;: \u0026#34;172.19.0.1\u0026#34; 25 } 26 ] 27 }, 28 \u0026#34;Internal\u0026#34;: false, 29 \u0026#34;Attachable\u0026#34;: false, 30 \u0026#34;Containers\u0026#34;: { 31 \u0026#34;f32013a3de270374e0baf8e030e7182f0a75024a796b2459e703f15deeb48725\u0026#34;: { 32 \u0026#34;Name\u0026#34;: \u0026#34;gateway_f32013a3de27\u0026#34;, 33 \u0026#34;EndpointID\u0026#34;: \u0026#34;376c39efa00c1cd178d27f5daec7ffcb0ed06f71db8e15bab66834bb438342a2\u0026#34;, 34 \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:13:00:02\u0026#34;, 35 \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.19.0.2/16\u0026#34;, 36 \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; 37 } 38 }, 39 \u0026#34;Options\u0026#34;: { 40 \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;false\u0026#34;, 41 \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, 42 \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker_gwbridge\u0026#34; 43 }, 44 \u0026#34;Labels\u0026#34;: {} 45 } 46] 47 48docker network disconnect -f docker_gwbridge gateway_def4bf4c78ab 49 50docker network rm docker_gwbridge ","permalink":"https://omgkill.github.io/bak/docker/%E4%BD%BF%E7%94%A8docker%E5%90%AF%E5%8A%A8%E5%8E%8B%E6%B5%8B%E6%9C%8D/","tags":null,"title":""},{"categories":null,"contents":" 申请端口 check out svn文档，svn地址：http://svn.super-chameleon.com:8822/svn/AMS_TD/Source/trunk/Server/Tools/Ops/ds/port.xlsx 填写自己的名字和端口（端口从10000开始，依次增加，不要重复），提交svn 下载脚本 脚本地址：http://svn.super-chameleon.com:8822/svn/AMS_TD/Source/trunk/Server/Tools/Ops/ds/deploy_docker_game.sh 执行脚本 ./deploy_docker_game.sh -p 端口 -s 服id -n 容器名 端口 端口就是上面申请的端口 服id 这个服id有两个选项，一个是自己的服id，一个是共通使用一个服id 如果是开发，可以使用自己的服id 如果是运营，可以使用共通的服id。共通服id:9000 容器名 这个最好是使用者的名字，以后好区分 一个额外参数 -b，mysql 参数 INNODB_BUFFER_POOL_SIZE， 单位是M,不填默认值是128M 示例：./deploy_docker_game.sh -p 10000 -s 11 -n name -b 6144 脚本执行，会有log显示 看到deploy success说明部署成功 tips docker 目前只支持linux 可以在10.0.3.2服测试/home/ams2/ds 如何操作容器\n通过管理界面操作\nhttp://10.0.3.2:9000/#!/home 或者通过命令行操作容器\n查看当前机器有哪些容器 docker ps 或者 docker container ls 运行容器(这个需要谷歌一下，命令参数比较多) docker run -d 容器名 进入容器 docker exec -it 容器名 bash 退出容器 exit 关闭容器 docker stop 容器名 开启容器 docker start 容器名 但是这个不会启动服务，最好的方式是删除容器，然后使用docker run 删除容器 docker rm 容器名 强制删除 docker rm -f 容器名 查看容器日志 docker logs 容器名 docker logs -f 容器名 容器内ams2部署地址 /home/ams2_deploy 容器内Mysql地址 /home/elex/mysql 容器内Cluster Redis 地址 /home/elex/redis ","permalink":"https://omgkill.github.io/bak/docker/%E4%BD%BF%E7%94%A8docker%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95%E6%9C%8D/","tags":null,"title":""},{"categories":null,"contents":"代码解决方案\n1. 问题：逻辑有点复杂，还要在复杂的逻辑上修改\r- 解决方案：\r- 1. 改动小，代码执行是没问题。但不容易理解\r- 2. 改动大，代码是解构的。更容易理解\r- 最终解决\r- 选择的方案2\r- 原因：\r- 结构清晰，更容易理解\r- reviewer也更容易看明白，确保没有问题\r2. 问题：leader希望复用共同的逻辑，但配置却是独立的，没有用共同的。同时配置又深入嵌入到逻辑的各处\r- leader希望的\r- 复用共同逻辑，可以用模板方法解决\r- 我一开始的做法\r- 只共用一个接口，逻辑代码是copy的\r- 这样就又冲突了。\r- 最后方案\r- 使用适配器模式，通过一个配置类关联两个独立的配置\r- 这样底层的配置读取就是共同的，不需要做特殊处理。后续相关的活动也可以这样处理\r- 创建一个stage类，然后再创建stageGc类并继承stage。同时一个配置解析类\r","permalink":"https://omgkill.github.io/bak/%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97/%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","tags":null,"title":""},{"categories":null,"contents":"","permalink":"https://omgkill.github.io/search/","tags":null,"title":"Search Results"}]