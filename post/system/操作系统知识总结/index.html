<!DOCTYPE html>
<html
  lang="en"
  itemscope
  itemtype="http://schema.org/WebPage"
>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>
          操作系统面试题 - MMM
        </title>
    

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="啊沉" />
  <meta name="description" content="操作系统面试题 为解决 • 计算机系统存储体系 cpu寄存器、高速缓存、内存、硬盘 • 程序运行时的内存结构 程序代码、堆、栈 • 计算机文件系统，页表结构 一" />

  <meta name="keywords" content="java, linux, game server" />






<meta name="generator" content="Hugo 0.115.4" />


<link rel="canonical" href="https://omgkill.github.io/post/system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.124c859f46493cdcfd07514fe07d622ed4515a7eb0ab351d10cfd83c2cd6979c.css" integrity="sha256-EkyFn0ZJPNz9B1FP4H1iLtRRWn6wqzUdEM/YPCzWl5w=" media="screen" crossorigin="anonymous">







<meta property="og:title" content="操作系统面试题" />
<meta property="og:description" content="操作系统面试题 为解决 • 计算机系统存储体系 cpu寄存器、高速缓存、内存、硬盘 • 程序运行时的内存结构 程序代码、堆、栈 • 计算机文件系统，页表结构 一" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://omgkill.github.io/post/system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-07-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-07-01T00:00:00+00:00" />
<meta itemprop="name" content="操作系统面试题">
<meta itemprop="description" content="操作系统面试题 为解决 • 计算机系统存储体系 cpu寄存器、高速缓存、内存、硬盘 • 程序运行时的内存结构 程序代码、堆、栈 • 计算机文件系统，页表结构 一"><meta itemprop="datePublished" content="2020-07-01T00:00:00+00:00" />
<meta itemprop="dateModified" content="2020-07-01T00:00:00+00:00" />
<meta itemprop="wordCount" content="12463">
<meta itemprop="keywords" content="operation system,knowledge summary," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="操作系统面试题"/>
<meta name="twitter:description" content="操作系统面试题 为解决 • 计算机系统存储体系 cpu寄存器、高速缓存、内存、硬盘 • 程序运行时的内存结构 程序代码、堆、栈 • 计算机文件系统，页表结构 一"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




  </head>
  <body>
    <div id="back-to-top"></div>

    <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">MMM</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/">This is Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/categories/">Categories</a>
          
        
      </li>
    

    
  </ul>
</nav>


    
      






  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css" integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css" integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin="anonymous">




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

    

    

    


    <header id="header" class="header">
      <div class="logo-wrapper">
  <a href="/" class="logo">
    
      MMM
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/">This is Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/categories/">Categories</a>
          

        

      </li>
    

    
    
    <li class="menu-item">
      <a class="menu-item-link">
        <form action="/search" method="GET">
          <input type="search" name="s" id="search-query" placeholder="">
          <button type="submit">search</button>
        </form>
      </a>
    </li>
    
  </ul>
</nav>

    </header>

    <div id="mobile-panel">
      <main id="main" class="main bg-llight wallpaper">
        <div class="content-wrapper">
    <div id="content" class="content">
      <article class="post">
        
        <header class="post-header">
          <h1 class="post-title">操作系统面试题</h1>
          

          <div class="post-meta">
  <div class="post-meta-author">
    by
      <a href="/about">
        <span class="post-meta-author-name">
          啊沉
        </span>
      </a>
    
  </div>

  <div class="post-meta-time">
    <time datetime="2020-07-01">
      2020-07-01
    </time>
  </div>

  


  <div class="post-meta__right">
    <span class="post-meta-more">
        12463 words -
        25 min read
      </span>

    <div class="post-meta-category">
        <a href="https://omgkill.github.io/categories/system/"> system </a>
          
      </div>


    
    


    
    
  </div>
</div>

        </header>

        
        <div class="post-content">
          <h1 id="操作系统面试题">操作系统面试题</h1>
<p>为解决</p>
<ul>
<li>
<p>• 计算机系统存储体系</p>
<p>cpu寄存器、高速缓存、内存、硬盘</p>
</li>
<li>
<p>• 程序运行时的内存结构</p>
<p>程序代码、堆、栈</p>
</li>
<li>
<p>• 计算机文件系统，页表结构</p>
<p><strong>一个文件由目录项、inode和数据块组成。</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-0-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-0-1">1</a></span><span>    **1. 目录项：包括文件名和inode节点号。
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-0-2"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-0-2">2</a></span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-0-3"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-0-3">3</a></span><span>    2. Inode：又称文件索引节点，包含文件的基础信息以及数据块的指针。
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-0-4"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-0-4">4</a></span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-0-5"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-0-5">5</a></span><span>    3. 数据块：包含文件的具体内容。**
</span></span></code></pre></div><p>页表主要用于计算机内存的虚拟化，每个进程都是一个虚拟的内存地址。然后通过页表去映射到对应内存上。</p>
</li>
<li>
<p>• 正数和负数及其浮点数是如何在计算机中表示的?</p>
<p>正数使用原码</p>
<p>负数使用补码</p>
<p>浮点数是一个整数乘以2的整数次幂得到。</p>
<p>对于float是1位正负，8位指数，其他位是尾数</p>
</li>
<li>
<p>谈谈你对线程的认识？</p>
<p>线程的结构有线程上下文、执行栈、局部变量。</p>
<p>线程依赖进程获取进程获取资源</p>
<ul>
<li>线程相当于进程内的一个独立操作的程序计数器</li>
<li>线程创建销毁比进程少</li>
<li>如果是进程的线程切换也很小</li>
<li>同进程的线程更易于通信</li>
</ul>
</li>
<li>
<p>如果默认每个线程使用1mb堆栈空间，则32位地址空间，哪么理论上最大可以开多少组线程？</p>
<p>3000个线程</p>
</li>
<li>
<p><em><strong>*解释一下什么是操作系统*</strong></em></p>
<ol>
<li>可以管理和运行硬件，硬件可以通过驱动扩展</li>
<li>给软件提供了一个平台。软件无需关心硬件处理，更容易去使用硬件的功能</li>
<li>更有效地使用资源。比如内存和cpu资源，需要一种有效的方式去管理</li>
</ol>
</li>
<li>
<p>计算机包含什么</p>
<ol>
<li>处理器、存储设备和输入输出部件组成</li>
<li>cpu、寄存器、内存、磁盘、系统总线、gpu、主板、键盘、鼠标、电源</li>
</ol>
</li>
<li>
<p><em><strong>*进程和线程的区别？*</strong></em></p>
<p>进程</p>
<ol>
<li>进程有资源所有权，包括内存，io设备，io通道，文件</li>
<li>进程是操作系统调度</li>
<li>进程是处理器执行的实体</li>
</ol>
<p>线程</p>
<ol>
<li>为什么要有线程呢：比如说，我有多个逻辑想要并发处理，那我创建多个进程，这里就有几个问题：
<ol>
<li>进程的创建和停止比较耗时</li>
<li>一个是进程的切换耗费资源，</li>
<li>另一个是多个进程如果共享一个资源还要进程间加锁处理。</li>
<li>进程间的通信也比较耗时
<ol>
<li>进程间是如何通信的</li>
</ol>
</li>
</ol>
</li>
<li>线程是在进程里创建的，只包含处理逻辑，共享整个进程的资源</li>
<li>线程比进程创建时间少许多</li>
<li>终止线程比进程花费时间少</li>
<li>线程切换比进程切换时间少</li>
<li>线程提高了不同的执行程序间通信的效率
<ol>
<li>进程之间如何通信</li>
</ol>
</li>
</ol>
<p>举例说明：文件服务器。当每个新文件请求到达是，会创建新的线程，结束后要销毁。一个进程的多线程可以在多个处理器执行。线程共享数据，线程间传递消息比进程更快</p>
</li>
<li>
<p>linux 多核如何调度一个进程里的多个线程</p>
</li>
<li>
<p>线程分类</p>
<ul>
<li>
<p>内核线程</p>
<p>有关线程管理的所有工作都是内核完成的，包括创建、撤销和切换都是内核实现的</p>
</li>
<li>
<p>用户线程</p>
<p>由用户程序来管理线程的，通过线程库来创建和销魂线程，内核意识不到线程的存在</p>
<ul>
<li>
<p>线程库是什么</p>
<p>线程库事用于用户级线程管理的一个例程包，它包含用于创建和销毁线程的代码、在线程间传递消息和数据的代码、调度线程执行的代码，以及保护和恢复线程上下文的代码</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>内核线程与用户线程的优缺点</p>
<ul>
<li>用户线程比内核线程优点
<ol>
<li>由于所有线程管理的数据结构都在一个进程的用户空间地址中，线程切换不需要内核态特权，因此，进程不需要为了线程管理而切换到内核态，这节省了两次状态转换（从用户态到内核态；从内核态返回到用户态）的开销</li>
<li>调度可以是应用程序相关的。可以根据应用的业务自己调度线程</li>
<li>用户级线程可以在任何操作系统运行，不需要对底层内核进行修改以支持用户级线程。线程库是一组供所有应用程序共享的应用程序级别的函数</li>
</ol>
</li>
<li>用户线程比内核线程缺点
<ol>
<li>在典型的操作系统中，许多系统调用都会引起阻塞。一个线程调用，导致整个进程的线程都阻塞</li>
<li>在纯粹的用户级线程策略中，一个多线程应用程序不能利用多处理器</li>
</ol>
</li>
</ul>
</li>
<li>
<p>线程的状态</p>
<ul>
<li>就绪、运行、结束、阻塞</li>
</ul>
</li>
<li>
<p>进程的状态</p>
<p>新建、就绪、运行、推出、挂起、阻塞、就绪/挂起、阻塞/挂起</p>
</li>
<li>
<p>线程拥有什么</p>
<ol>
<li>线程执行状态（运行，就绪）</li>
<li>在未运行时保存的线程上下文；从某种意义上看，线程可被视为进程内的一个独立操作的程序计数器</li>
<li>一个执行栈</li>
<li>用于每个线程局部变量的静态存储空间</li>
<li>与进程内的其他线程共享的对进程的内存和资源访问</li>
</ol>
</li>
<li>
<p><em><strong>*协程与线程的区别*</strong></em></p>
<ul>
<li>协程
<ol>
<li><strong>协程就是可以由程序自行控制挂起（暂停执行）、恢复（继续在原来暂停的地方执行）的程序</strong></li>
<li><strong>他可以用来实现多任务的协作执行</strong></li>
<li>协程是在线程里创建的，所以协程是串行处理的。</li>
<li>协程创建和暂停的消耗低</li>
</ol>
</li>
</ul>
</li>
<li>
<p><em><strong>*并发和并行有什么区别*</strong></em></p>
<p>并行是多个任务在多个处理器执行。 并发是多个任务同时执行，可能是多个处理器，也可能是单个处理器，然后分片执行</p>
</li>
<li>
<p><em><strong>*进程与线程的切换流程？*</strong></em></p>
<ul>
<li>
<p>进程切换：</p>
<p>进入内核态</p>
<p>1）保存处理器上下文环境，包括程序计数器和其他寄存器。 2）更新当前处于运行态进程的进程控制块，包括将进程的状态改变到另一状态（就绪态、阻塞态、就绪挂起态或退出态）还必须更新其他相关域，包括离开运行态的原因和记账信息。 3）将进程的进程控制块移到相应的队列（就绪、在事件i处阻塞、就绪挂起）。 4）选择另一个进程执行，这方面的内容将在本书的第四部分探讨。 5）更新所选择进程的进程控制块，包括将进程的状态变为运行态。 6）更新内存管理的数据结构，这取决于如何管理地址转换，这方面的内容将在第三部分探讨。 7）恢复处理器在被选择的进程最近一次切换出运行状态时的上下文环境，这可以通过载人程序计数器和其他寄存器以前的值来实现，</p>
<p>进入用户态</p>
<p>对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2步是进程和线程切换都要做的。</p>
<p>因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p>
</li>
</ul>
</li>
<li>
<p>进程切换原因</p>
<p>中断（时钟中断），陷阱（运行异常），系统调用（内存失效）</p>
</li>
<li>
<p><em><strong>*为什么虚拟地址空间切换会比较耗时？*</strong></em></p>
<p>别人说的：</p>
<p>进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个Cache就是TLB（translation Lookaside Buffer，TLB本质上就是一个Cache，是用来加速页表查找的）。</p>
<p>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，Cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p>
<p>自己想的：</p>
<p>我们读取一个地址，实际需要访问两次内存。一次是根据页号找到页表数据，一次根据物理地址读取数据。这个是非常耗时的。所以我们希望有一个缓存来保存逻辑地址与物理的地址的映射，这个就实TLB。保存在寄存器了。如果我们切换进程了，那这个就失效了，就导致需要重新缓存。</p>
</li>
<li>
<p><em><strong>*进程间通信方式有哪些？*</strong></em></p>
<ul>
<li>
<p>管道/管程：管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<p>管道可以分为两类：匿名管道和命名管道。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
</li>
<li>
<p>信号 ： 信号是一种比较复杂的通信方式，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p>
<blockquote>
<p>Linux系统中常用信号：（1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。</p>
<p>（2）<strong>SIGINT</strong>：程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。</p>
<p>（3）<strong>SIGQUIT</strong>：程序退出信号。程序运行过程中，按<code>Ctrl+\\\\</code>键将产生该信号。</p>
<p>（4）<strong>SIGBUS和SIGSEGV</strong>：进程访问非法地址。</p>
<p>（5）<strong>SIGFPE</strong>：运算中出现致命错误，如除零操作、数据溢出等。</p>
<p>（6）<strong>SIGKILL</strong>：用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。</p>
<p>（7）<strong>SIGTERM</strong>：结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。</p>
<p>（8）<strong>SIGALRM</strong>：定时器信号。</p>
<p>（9）<strong>SIGCLD</strong>：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p>
</blockquote>
</li>
<li>
<p>信号量：信号量是一个<strong>计数器</strong>，可以用来控制多个进程对共享资源的访问。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</li>
<li>
<p>消息队列：消息队列是消息的链接表，包括Posix消息队列和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li>
<p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
</li>
<li>
<p>Socket：与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>管道：速度慢，容量有限；</li>
<li>Socket：任何进程间都能通讯，但速度慢；</li>
<li>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题；</li>
<li>信号量：不能传递复杂消息，只能用来同步；</li>
<li>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</li>
</ul>
</li>
<li>
<p><em><strong>*进程间同步的方式有哪些？*</strong></em></p>
<p>1、临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</p>
<p>优点：保证在某一时刻只有一个线程能访问数据的简便办法。</p>
<p>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。</p>
<p>2、互斥量：为协调共同对一个共享资源的单独访问而设计的。互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。</p>
<p>优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p>
<p>缺点：</p>
<ul>
<li>互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。</li>
<li>通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。</li>
</ul>
<p>3、信号量：为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了。</p>
<p>优点：适用于对Socket（套接字）程序中线程的同步。</p>
<p>缺点:</p>
<ul>
<li>信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点；</li>
<li>信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担；</li>
<li>核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。</li>
</ul>
<p>4、事件： 用来通知线程有一些事件已发生，从而启动后继任务的开始。</p>
<p>优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。</p>
</li>
<li>
<p><em><strong>*线程同步的方式有哪些？*</strong></em></p>
<p>一个回答：</p>
<p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p>
<ol>
<li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semaphore)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
<hr>
<p>另一个回答：</p>
<p>1、临界区：当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止，以此达到用原子方式操 作共享资源的目的。</p>
<p>2、事件：事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。</p>
<p>3、互斥量：互斥对象和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。</p>
<p>4、信号量：当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。</p>
<p>区别：</p>
<ul>
<li>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说互斥量可以跨越进程使用，但创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</li>
<li>互斥量，信号量，事件都可以被跨越进程使用来进行同步数据操作。</li>
</ul>
</li>
<li>
<p><em><strong>*什么是临界区，如何解决冲突？*</strong></em></p>
<p>每个进程中访问临界资源的那段程序称为临界区，<strong>一次仅允许一个进程使用的资源称为临界资源。</strong></p>
<p>解决冲突的办法：</p>
<ul>
<li>如果有若干进程要求进入空闲的临界区，<strong>一次仅允许一个进程进入</strong>，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</li>
<li>进入临界区的进程要在<strong>有限时间内退出</strong>。</li>
<li>如果进程不能进入自己的临界区，则应<strong>让出CPU</strong>，避免进程出现“忙等”现象。</li>
</ul>
</li>
<li>
<p><em><strong>*什么是死锁？死锁产生的条件？*</strong></em></p>
<p><strong>什么是死锁</strong>：</p>
<p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>
<p><strong>死锁产生的四个必要条件</strong>：（有一个条件不成立，则不会产生死锁）</p>
<ul>
<li>互斥条件：一个资源一次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>
<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>
</ul>
<p><strong>如何处理死锁问题</strong>：</p>
<p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p>
<ul>
<li><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li>
<li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li>
<li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li>
<li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li>
</ul>
<hr>
</li>
<li>
<p><em><strong>*进程调度策略有哪几种？*</strong></em></p>
<ul>
<li>
<p><strong>先来先服务</strong>：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对<code>I/O</code>密集型进程也不利，因为这种进程每次进行<code>I/O</code>操作之后又得重新排队。</p>
</li>
<li>
<p><strong>短作业优先</strong>：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
</li>
<li>
<p><strong>最短剩余时间优先</strong>：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
</li>
<li>
<p><strong>时间片轮转</strong>：将所有就绪进程按 <code>FCFS</code> 的原则排成一个队列，每次调度时，把 <code>CPU</code> 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 <code>CPU</code> 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。</p>
</li>
<li>
<p><strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
</li>
<li>
<p>多级反馈队列，根据队列预测未来。 比如不知道进程的运行时间，不知道运行密集型，还是交互型。我们想要把交互型的响应时间要短，运行密集型调度时间要少。</p>
</li>
</ul>
</li>
<li>
<p><em><strong>*什么是分页？*</strong></em></p>
<p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p>
<p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p>
<p><a href="https://segmentfault.com/img/bVcSKjQ">https://segmentfault.com/img/bVcSKjQ</a></p>
</li>
<li>
<p><strong>什么是分段？</strong></p>
<p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p>
<p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p>
<p><a href="https://segmentfault.com/img/bVcSKjR">https://segmentfault.com/img/bVcSKjR</a></p>
</li>
<li>
<p><em><strong>*分页和分段有什区别？*</strong></em></p>
<ul>
<li>分页对程序员是透明的，但是分段需要程序员显式划分每个段。</li>
<li>分页的地址空间是一维地址空间，分段是二维的。</li>
<li>页的大小不可变，段的大小可以动态改变。</li>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<p>另一个回答：</p>
<ul>
<li>
<p>共同点</p>
<p>：</p>
<ul>
<li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li>
<p>区别</p>
<p>：</p>
<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要</li>
</ul>
</li>
</ul>
<hr>
<p>著作权归所有 原文链接：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html</p>
</li>
<li>
<p><em><strong>*什么是交换空间？*</strong></em></p>
<p>操作系统把物理内存(physical RAM)分成一块一块的小内存，每一块内存被称为<strong>页(page)</strong>。当内存资源不足时，<strong>Linux把某些页的内容转移至硬盘上的一块空间上，以释放内存空间</strong>。硬盘上的那块空间叫做<strong>交换空间</strong>(swap space),而这一过程被称为交换(swapping)。<strong>物理内存和交换空间的总容量就是虚拟内存的可用容量。</strong></p>
<p>用途：</p>
<ul>
<li>物理内存不足时一些不常用的页可以被交换出去，腾给系统。</li>
<li>程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。</li>
</ul>
</li>
<li>
<p><em><strong>*页面替换算法有哪些？*</strong></em></p>
<p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>包括以下算法：</p>
<ul>
<li><strong>最佳算法</strong>：所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。这是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</li>
<li><strong>先进先出</strong>：选择换出的页面是最先进入的页面。该算法将那些经常被访问的页面也被换出，从而使缺页率升高。</li>
<li><strong>LRU</strong>：虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。<code>LRU</code> 将最近最久未使用的页面换出。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 <code>LRU</code> 代价很高。</li>
<li><strong>时钟算法</strong>：时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。它将整个环形链表的每一个页面做一个标记，如果标记是<code>0</code>，那么暂时就不会被替换，然后时钟算法遍历整个环，遇到标记为<code>1</code>的就替换，否则将标记为<code>0</code>的标记为<code>1</code>。</li>
</ul>
</li>
<li>
<p><em><strong>*什么是缓冲区溢出？有什么危害？*</strong></em></p>
<p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>
<p>危害有以下两点：</p>
<ul>
<li>程序崩溃，导致拒绝额服务</li>
<li>跳转并且执行一段恶意代码</li>
</ul>
<p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p>
</li>
<li>
<p><em><strong>*什么是虚拟内存？*</strong></em></p>
<p>虚拟内存就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。</p>
</li>
<li>
<p><em><strong>*讲一讲IO多路复用？*</strong></em></p>
<p><strong>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合</strong>：</p>
<ul>
<li>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li>
<li>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</li>
</ul>
</li>
<li>
<p><em><strong>*硬链接和软链接有什么区别？*</strong></em></p>
<ul>
<li>硬链接就是在目录下创建一个条目，记录着文件名与 <code>inode</code> 编号，这个 <code>inode</code> 就是源文件的 <code>inode</code>。删除任意一个条目，文件还是存在，只要引用数量不为 <code>0</code>。但是硬链接有限制，它不能跨越文件系统，也不能对目录进行链接。</li>
<li>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 <code>Windows</code> 的快捷方式。当源文件被删除了，链接文件就打不开了。因为记录的是路径，所以可以为目录建立符号链接。</li>
</ul>
</li>
<li>
<p>中断的处理过程?</p>
<ol>
<li>保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。</li>
<li>开中断：以便执行中断时能响应较高级别的中断请求。</li>
<li>中断处理</li>
<li>关中断：保证恢复现场时不被新中断打扰</li>
<li>恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。</li>
</ol>
</li>
<li>
<p><em><strong>*中断和轮询有什么区别？*</strong></em></p>
<ul>
<li>轮询：CPU对<strong>特定设备</strong>轮流询问。中断：通过<strong>特定事件</strong>提醒CPU。</li>
<li>轮询：效率低等待时间长，CPU利用率不高。中断：容易遗漏问题，CPU利用率不高。</li>
</ul>
</li>
<li>
<p>**什么是系统调用呢？**能不能详细介绍一下。</p>
<p>介绍系统调用之前，我们先来了解一下用户态和系统态。</p>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li>
<li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>说了用户态和系统态之后，那么什么是系统调用呢？</p>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<hr>
<p>著作权归所有 原文链接：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html</p>
</li>
<li>
<p><strong>操作系统的内存管理主要是做什么？</strong></p>
<p>操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情</p>
</li>
<li>
<p><em><strong>*局部性原理*</strong></em></p>
<p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>
<blockquote>
<p>以下内容摘自《计算机操作系统教程》 第 4 章存储器管理。</p>
</blockquote>
<p>早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存</p>
<hr>
<p>著作权归所有 原文链接：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html</p>
</li>
<li>
<p><strong>什么是虚拟内存(Virtual Memory)?</strong></p>
<p>这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。<strong>为什么可以这样呢？</strong> 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p>
<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。推荐阅读：<a href="https://juejin.im/post/59f8691b51882534af254317">《虚拟内存的那点事儿》open in new window</a></p>
<p>维基百科中有几句话是这样介绍虚拟内存的。</p>
<blockquote>
<p>虚拟内存 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:https://zh.wikipedia.org/wiki/虚拟内存</p>
</blockquote>
<hr>
<p>著作权归所有 原文链接：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html</p>
</li>
<li>
<p><strong>虚拟内存技术的实现呢？</strong></p>
<p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong></p>
<p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p>
<p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
<hr>
<p>著作权归所有 原文链接：https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html</p>
</li>
<li>
<p>什么是银行家算法？是不是可以把其他算法都拉出来看看</p>
<p>银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。安全的状态指的是一个进程序列{P1,P2,&hellip;Pn}，对于每一个进程Pi，它以后尚需要的资源不大于当前资源剩余量和其余进程所占有的资源量之和。</p>
</li>
</ul>
<p>参考：</p>

        </div>

        
        
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">啊沉</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2020-07-01
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>



        
        


        <footer class="post-footer">
          <div class="post-tags">
              <a href="https://omgkill.github.io/tags/operation-system/">operation system</a>
                <a href="https://omgkill.github.io/tags/knowledge-summary/">knowledge summary</a>
                
            </div>


          
          <nav class="post-nav">
            
              <a class="prev" href="/post/game/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E6%8B%A5%E6%9C%89%E8%B5%84%E6%BA%90%E6%9C%80%E5%A4%9A%E7%8E%A9%E5%AE%B6/">
                
                <i class="iconfont">
                  <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

                </i>
                <span class="prev-text nav-default">一个查询拥有资源最多玩家</span>
                <span class="prev-text nav-mobile">Prev</span>
              </a>
            
              <a class="next" href="/post/linux/linux%E5%91%BD%E4%BB%A4/">
                <span class="next-text nav-default">Linux命令</span>
                <span class="prev-text nav-mobile">Next</span>
                
                <i class="iconfont">
                  <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

                </i>
              </a>
          </nav>
        </footer>
      </article>

      
      


      
      

  

  
  

  
  

  

  

    

  

  


    </div>

    
    


  </div>

      </main>

      <footer id="footer" class="footer">
        <div class="icon-links">
  











</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    2023
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        啊沉
        
      </span></span>

  
  

  
</div>

      </footer>

      <div class="button__back-to-top">
        <a href="#back-to-top">
          <i class="iconfont">
            
            <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

          </i>
        </a>
      </div>
    </div>
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>




<script type="text/javascript" src="/js/main.4d48757c2b8fd379d865928e86a0521f650d2166e90744348e70a32d185e0131.js" integrity="sha256-TUh1fCuP03nYZZKOhqBSH2UNIWbpB0Q0jnCjLRheATE=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.js" integrity="sha256-AC9ChpELidrhGHX23ZU53vmRdz3FhKaN9E28+BbcWBw=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js" integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin="anonymous"></script>
  

















  </body>
</html>
