<!DOCTYPE html>
<html
  lang="en"
  itemscope
  itemtype="http://schema.org/WebPage"
>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>
          计算机网络面试题 - MMM
        </title>
    

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="啊沉" />
  <meta name="description" content="计算机网络面试题 未解决的 滑动窗口技术 滑动窗口（Sliding window）是一种流量控制技术。 早期的网络通信中，通信双方不会考虑网络的 拥挤情" />

  <meta name="keywords" content="java, linux, game server" />






<meta name="generator" content="Hugo 0.115.4" />


<link rel="canonical" href="https://omgkill.github.io/post/d-%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.124c859f46493cdcfd07514fe07d622ed4515a7eb0ab351d10cfd83c2cd6979c.css" integrity="sha256-EkyFn0ZJPNz9B1FP4H1iLtRRWn6wqzUdEM/YPCzWl5w=" media="screen" crossorigin="anonymous">







<meta property="og:title" content="计算机网络面试题" />
<meta property="og:description" content="计算机网络面试题 未解决的 滑动窗口技术 滑动窗口（Sliding window）是一种流量控制技术。 早期的网络通信中，通信双方不会考虑网络的 拥挤情" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://omgkill.github.io/post/d-%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-06-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-01T00:00:00+00:00" />
<meta itemprop="name" content="计算机网络面试题">
<meta itemprop="description" content="计算机网络面试题 未解决的 滑动窗口技术 滑动窗口（Sliding window）是一种流量控制技术。 早期的网络通信中，通信双方不会考虑网络的 拥挤情"><meta itemprop="datePublished" content="2023-06-01T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-06-01T00:00:00+00:00" />
<meta itemprop="wordCount" content="17990">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="计算机网络面试题"/>
<meta name="twitter:description" content="计算机网络面试题 未解决的 滑动窗口技术 滑动窗口（Sliding window）是一种流量控制技术。 早期的网络通信中，通信双方不会考虑网络的 拥挤情"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




  </head>
  <body>
    <div id="back-to-top"></div>

    <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">MMM</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/">This is Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/categories/">Categories</a>
          
        
      </li>
    

    
  </ul>
</nav>


    
      






  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css" integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css" integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin="anonymous">




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

    

    

    


    <header id="header" class="header">
      <div class="logo-wrapper">
  <a href="/" class="logo">
    
      MMM
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/">This is Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://omgkill.github.io/categories/">Categories</a>
          

        

      </li>
    

    
    
    <li class="menu-item">
      <a class="menu-item-link">
        <form action="/search" method="GET">
          <input type="search" name="s" id="search-query" placeholder="">
          <button type="submit">search</button>
        </form>
      </a>
    </li>
    
  </ul>
</nav>

    </header>

    <div id="mobile-panel">
      <main id="main" class="main bg-llight wallpaper">
        <div class="content-wrapper">
    <div id="content" class="content">
      <article class="post">
        
        <header class="post-header">
          <h1 class="post-title">计算机网络面试题</h1>
          

          <div class="post-meta">
  <div class="post-meta-author">
    by
      <a href="/about">
        <span class="post-meta-author-name">
          啊沉
        </span>
      </a>
    
  </div>

  <div class="post-meta-time">
    <time datetime="2023-06-01">
      2023-06-01
    </time>
  </div>

  


  <div class="post-meta__right">
    <span class="post-meta-more">
        17990 words -
        36 min read
      </span>

    


    
    


    
    
  </div>
</div>

        </header>

        
        <div class="post-content">
          <h1 id="计算机网络面试题">计算机网络面试题</h1>
<p>未解决的</p>
<ul>
<li>
<p>滑动窗口技术</p>
<p>滑动窗口（Sliding window）是一种流量控制技术。</p>
<p>早期的网络通信中，通信双方不会考虑网络的 拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包， 谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种 技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包 （称窗口尺寸）。
————————————————
版权声明：本文为CSDN博主「一米九零小胖子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：<a href="https://blog.csdn.net/weixin_47156401/article/details/125890118">https://blog.csdn.net/weixin_47156401/article/details/125890118</a></p>
</li>
<li>
<p>请解释DOS攻击与DRDOS攻击的基本原理</p>
</li>
<li>
<p>一个100Byte数据包，精简到50Byte, 其传输效率提高了50%</p>
<ul>
<li>发送时间快了</li>
<li>等待时间快了</li>
<li>阻塞的概率低了</li>
</ul>
</li>
<li>
<p>Select
select是io多路复用</p>
<ul>
<li>select 作用是什么
<ul>
<li>
<ol>
<li>我们扔一坨fd给内核；</li>
</ol>
</li>
<li>
<ol>
<li>内核自己遍历（相当于集群内的遍历）fd，看哪个有数据；</li>
</ol>
</li>
<li>
<ol>
<li>返回int，代表有几个fd有数据；</li>
</ol>
</li>
<li>我们拿到返回，
<ul>
<li>
<ol>
<li>遍历所有的fd，判断是否有数据（<strong>不需要进行系统调用，内核已经标记了哪些fd有数据</strong>）；</li>
</ol>
</li>
<li>
<ol>
<li>如果这个fd有数据，读它；</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Epoll，边缘触发与<strong>水平触发</strong>点区别与应用</p>
<p>水平触发LT：
优点：程序简单，会完整地读取所有数据。
缺点：重复地事件触发会影响高并发服务器地性能，因为epoll监控事件涉及到系统调用，需要用户态-内核态的转换。LT消耗了大量的系统资源，影响服务器性能；
边沿触发ET：
优点：每次epoll_wait只用触发一次，通过程序逻辑实现读取缓冲区的所有数据，工作效率高，大大提升了服务器性能；
缺点（没归纳出来，随便写一个）：不能保证数据的完整。（这个可以通过上面提到的程序逻辑实现完整地读取数据</p>
<p>EPOLL水平触发和边沿触发都有各自适用的应用场景，具体如下：</p>
<p>EPOLL水平触发(LT)：</p>
<ol>
<li>适用于处理少量数据或者需要确保数据完整性的场景。</li>
<li>适用于使用阻塞式IO模型（如select）的应用程序迁移到epoll的过渡期。</li>
</ol>
<p>EPOLL边沿触发(ET):</p>
<ol>
<li>适用于高并发、高吞吐量的场景，即当数据流到达时，内核立即通知应用程序进行读写操作，避免了重复触发事件和重新读取套接字缓存的开销。</li>
<li>适用于需要精确控制的场景，即当数据流到达时，内核只会通知应用程序一次，如果应用程序没有完整地处理数据，则会在下一次epoll_wait()调用时再次通知应用程序进行读写操作。</li>
</ol>
<p>参考：</p>
<p>epoll的水平触发和边沿触发都有哪些应用场景？ - linux的回答 - 知乎
<a href="https://www.zhihu.com/question/272447529/answer/2980208393">https://www.zhihu.com/question/272447529/answer/2980208393</a></p>
</li>
<li>
<p>Select与Epoll的区别及应用</p>
<p>看 select、epool 的区别？底层的数据结构是什么</p>
<p>select 更适用与，连接少，但活跃的服务器。</p>
<p>epoll 更适用大量连接的服务</p>
<ul>
<li>
<p>参考</p>
<p><a href="https://blog.csdn.net/D_Guco/article/details/53166722">https://blog.csdn.net/D_Guco/article/details/53166722</a></p>
</li>
</ul>
</li>
<li>
<p>get和post区别？</p>
</li>
<li>
<p>拥塞控制了解吗? 比如快速重传等都有哪些方式? — 需要学习</p>
</li>
<li>
<p>可靠的udp的经典实现kcp了解吗? 我们为什么不用tcp? 实现可靠的udp必须做哪几个东西?</p>
<ul>
<li>kcp超时是，再次超时时间x1.5</li>
<li>kcp是选择重传</li>
<li>kcp延迟传输ack</li>
<li>kcp两种方式都可以，ack或者返回信息加入ack</li>
<li></li>
</ul>
</li>
<li>
<p>不做ack行吗?</p>
<p>可以，可以在返回报文加入ack</p>
</li>
<li>
<p>• 如果在网络不好的情况下,比如过山洞持续了半个小时,会不会有大量的包重试,浪费大量的流量,如何解决?</p>
</li>
<li>
<p>• ip协议的格式都有哪些内容? ip头部、ack</p>
</li>
<li>
<p>• select、epool 的区别？底层的数据结构是什么？</p>
<ul>
<li>
<p>select 作用是什么</p>
<ul>
<li>
<ol>
<li>我们扔一坨fd给内核；</li>
</ol>
</li>
<li>
<ol>
<li>内核自己遍历（相当于集群内的遍历）fd，看哪个有数据；</li>
</ol>
</li>
<li>
<ol>
<li>返回int，代表有几个fd有数据；</li>
</ol>
</li>
<li>我们拿到返回，
<ul>
<li>
<ol>
<li>遍历所有的fd，判断是否有数据（<strong>不需要进行系统调用，内核已经标记了哪些fd有数据</strong>）；</li>
</ol>
</li>
<li>
<ol>
<li>如果这个fd有数据，读它；</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><strong>epoll相对于select的优化（这个就是区别）</strong></strong></p>
<ul>
<li>
<ol>
<li>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可；</li>
</ol>
</li>
<li>
<ol>
<li><strong>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件（DMA）唤醒</strong>；</li>
</ol>
</li>
<li>
<ol>
<li>只返回就绪的fd；（fd是文件描述符，file descripe）</li>
</ol>
</li>
</ul>
</li>
<li>
<p>以上参考：</p>
<p><a href="https://puppylpg.github.io/2022/02/24/io-nio-aio/">https://puppylpg.github.io/2022/02/24/io-nio-aio/</a></p>
</li>
<li>
<p>epoll的底层数据结构是红黑树</p>
<ul>
<li>红黑树：最优。查找效率、空间利用高于hash，查找效率也高于btree/b+tree。</li>
<li>参考：<a href="https://blog.csdn.net/zhpCSDN921011/article/details/124522340">https://blog.csdn.net/zhpCSDN921011/article/details/124522340</a></li>
</ul>
</li>
<li>
<p>select是数组</p>
</li>
</ul>
</li>
<li>
<p><strong>TCP 的核心意涵是什么？</strong></p>
<p>TCP 是面向连接的可靠的传送协议。核心意涵就是面向连接与可靠，对于使用TCP socket而言我们要管理好socket的建立连接，断开连接等。同时对于业务逻辑而言TCP socket是可靠的不会丢包的，比如我发送ABCDE,这些数据包，不会出现丢包(ABDE)与乱序的情况(ACBED)。</p>
</li>
<li>
<p><strong>为什么TCP需要封包拆包协议？</strong></p>
<p>应用层发送数据的时候，每次发送会被开发人员认为是一个独立的数据包，可是在底层，由于TCP是可靠的传送协议，每次发送数据都要收到确认。所以底层有可能把应用层的两个数据包合并在一起发送，发送到另外一段的时候，可能一次收到两个应用层的数据包，而我们解析这些数据包的时候需要分成两个，所以我们在发送TCP命令包的时候要用标识能分开这两个数据包。所以就需要我们加一个封包拆包的协议。</p>
</li>
<li>
<p><strong>TCP 如何设计 封包与拆包协议？</strong></p>
<p>设计TCP封包拆包协议主要有两种方式，一种是大小+内容模式+校验模式，一种是特殊的分割符号的模式，比如\r\n, http协议就采用的是\r\n来进行分割。</p>
</li>
<li>
<p>connect如果非阻塞连接怎么处理，返回信息一般如何处理，通过什么方式知道连接完成, 已经发出的connect调用的socket再次调用connect会返回什么错误.</p>
</li>
<li>
<p>send 怎么获得socket最大发送数据大小，如果超过最大发送数据大小，会返回什么错误，如果持续发送数据，send返回什么错误，还可以继续发送数据吗？该怎么处理？多线程向同一个socket发送数据能保证顺序吗？</p>
</li>
<li>
<p>recv返回发送的总字节数，该字节数可能小于len参数中请求发送的数字 如果发生错误 返回？如果一次性收到数据比缓存大，那么怎么样知道 socket还有数据需要接收？</p>
</li>
<li>
<p>滑动窗口是干嘛的？</p>
</li>
<li>
<p>半连接队列 与全连接队列</p>
<ul>
<li>半连接队列 是客户端发了第一次连接，然后放到队列里。如果满了，就不下</li>
<li>全连接就是已经连接上了，然后发数据放入的队列。</li>
<li>参考：<a href="https://blog.csdn.net/m0_45406092/article/details/117933672">https://blog.csdn.net/m0_45406092/article/details/117933672</a></li>
</ul>
</li>
<li>
<p>backlog是啥</p>
<p>是全队连接队列的最大容量</p>
</li>
<li>
<p>能说清楚的面试题-就是知识已有，提的类型 不一样</p>
<ul>
<li><strong><strong>为什么TCP需要封包拆包协议？</strong></strong></li>
<li><strong><strong>TCP 如何设计 封包与拆包协议？</strong></strong></li>
<li>四次挥手很重要啊 - 1. TCP连接中的三次握手和四次挥手，四次挥手的最后一个ack的作用是什么，为什么要time wait，为什么是2msl。</li>
</ul>
</li>
</ul>
<h3 id="请简述-tcp-和-udp-的区别"><strong>请简述 TCP 和 UDP 的区别</strong></h3>
<ul>
<li>
<p>我的回答</p>
<ul>
<li>TCP和UDP的区别？</li>
</ul>
<p>（1）TCP是传输控制协议，UDP是用户数据报协议；</p>
<p>（2）TCP是面向连接的，可靠的数据传输协议，它要通过三次握手来建立连接，UDP是无连接的，不可靠的数据传输协议，采取尽力而为的策略，不保证接收方一定能收到正确的数据；</p>
<p>（3）TCP面向的是字节流，UDP面向的是数据报；</p>
<p>（4）TCP只支持点对点，UDP支持一对一，一对多和多对多；</p>
<p>（5）TCP有拥塞控制机制，UDP没有。</p>
</li>
<li>
<p>本来的回答</p>
<p><strong>思路：</strong> 这道题，校招的时候，问的概率高点，概念性的东西，<strong>TCP 是面向连接，而 UDP 是无连接</strong>。</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-fd1699aa297fdd9d109808150b5a71fa.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-fd1699aa297fdd9d109808150b5a71fa.png"></p>
<p>TCP 和 UDP 对比</p>
</li>
</ul>
<h3 id="请简单说一下你了解的端口及对应的服务"><strong>请简单说一下你了解的端口及对应的服务？</strong></h3>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-b651e46b88d855f852c6a8f0d93fcc08.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-b651e46b88d855f852c6a8f0d93fcc08.png"></p>
<h3 id="说下计算机网络体系结构"><strong>说下计算机网络体系结构</strong></h3>
<p>应用层：软件层</p>
<p>运输层：端系统到端系统之间的传输，报文段传输</p>
<p>网络层：点到点的传输，数据报的传输</p>
<p>链路层：结点到结点的传输，帧传输</p>
<p>物理层：物理的传输</p>
<p><strong>思路:</strong> 这道题主要考察候选人，<strong>计算机网络体系结构</strong>这个基础知识点。计算机网路体系结构呢，有三层：ISO 七层模型、TCP/IP 四层模型、五层体系结构。大家可以记住这个图，如下</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-7943d7dc8a2afb50c58f3467d45fa768.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-7943d7dc8a2afb50c58f3467d45fa768.png"></p>
<p>计算机网络体系结构</p>
<h3 id="iso-七层模型"><strong>ISO 七层模型</strong></h3>
<p>ISO 七层模型是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。</p>
<ul>
<li>应用层：网络服务与最终用户的一个接口，常见的协议有：<strong>HTTP FTP  SMTP SNMP DNS</strong>.</li>
<li>表示层：数据的表示、安全、压缩。，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</li>
<li>会话层：建立、管理、终止会话, 对应主机进程，指本地主机与远程主机正在进行的会话.</li>
<li>传输层：定义传输数据的协议端口号，以及流控和差错校验, 协议有 <strong>TCP UDP</strong>.</li>
<li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择, 协议有 <strong>ICMP IGMP IP 等</strong>.数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。</li>
<li>物理层：建立、维护、断开物理连接。”</li>
</ul>
<h3 id="tcpip-四层模型"><strong>TCP/IP 四层模型</strong></h3>
<ul>
<li>应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。</li>
<li>传输层: 对应 OSI 的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。</li>
<li>网际层：对应于 OSI 参考模型的网络层，主要解决主机到主机的通信问题。</li>
<li>网络接口层：与 OSI 参考模型的数据链路层、物理层对应。”</li>
</ul>
<h3 id="五层体系结构"><strong>五层体系结构</strong></h3>
<ul>
<li>应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。</li>
<li>传输层：对应 OSI 参考模型的的传输层</li>
<li>网络层：对应 OSI 参考模型的的网络层</li>
<li>数据链路层：对应 OSI 参考模型的的数据链路层</li>
<li>物理层：对应 OSI 参考模型的的物理层。”</li>
</ul>
<h3 id="从浏览器地址栏输入-url-到显示主页的过程"><strong>从浏览器地址栏输入 url 到显示主页的过程</strong></h3>
<p><strong>思路:</strong> 这道题主要考察的知识点是 HTTP 的请求过程，<strong>DNS 解析，TCP 三次握手，四次挥手这几个要点</strong>，我们都可以讲下。</p>
<ol>
<li>DNS 解析，查找域名对应的 IP 地址。</li>
<li>与服务器通过三次握手，建立 TCP 连接</li>
<li>向服务器发送 HTTP 请求</li>
<li>服务器处理请求，返回网页内容</li>
<li>浏览器解析并渲染页面</li>
<li>TCP 四次挥手，连接结束</li>
</ol>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-99845059382a3c88ea6190ef462d5432.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-99845059382a3c88ea6190ef462d5432.png"></p>
<h3 id="在交互过程中如果数据传送完了还不想断开连接怎么办怎么维持"><strong>在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</strong></h3>
<p>这个问题记住<code>keep-alive</code>就好，也就是说，在 HTTP 中响应体的 <strong>Connection</strong> 字段指定为<code>keep-alive</code>即可</p>
<h3 id="http-如何实现长连接在什么时候会超时"><strong>HTTP 如何实现长连接？在什么时候会超时？</strong></h3>
<p><strong>思路:</strong> 这道题实际上是考察 TCP 长连接的知识点，HTTP 的长连接实质是指 TCP 的长连接。至于什么时候超时，我们记住这几个参数如 <strong>tcp_keepalive_time</strong>、<strong>tcp_keepalive_probes</strong> 就好啦</p>
<p><strong>什么是 HTTP 的长连接？</strong></p>
<ol>
<li>HTTP 分为长连接和短连接，<strong>本质上说的是 TCP 的长短连接</strong>。TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才具有真正的长连接和短连接这一说法哈。</li>
<li>TCP 长连接可以复用一个 TCP 连接，来发起多次的 HTTP 请求，这样就可以减少资源消耗，比如一次请求 HTML，如果是短连接的话，可能还需要请求后续的 JS/CSS。</li>
</ol>
<p><strong>如何设置长连接？</strong></p>
<p>通过在头部（请求和响应头）设置 <strong>Connection</strong> 字段指定为<code>keep-alive</code>，HTTP/1.0 协议支持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。</p>
<p><strong>在什么时候会超时呢？</strong></p>
<p>★HTTP 一般会有 httpd 守护进程，里面可以设置 <strong>keep-alive timeout</strong>，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间TCP 的 <strong>keep-alive</strong> 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 <strong>tcp_keepalive_time</strong>，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 <strong>tcp_keepalive_probes</strong>，就会丢弃该连接。”</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-0-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-0-1">1</a></span><span>1. tcp_keepalive_intvl = 15
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-0-2"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-0-2">2</a></span><span>2. tcp_keepalive_probes = 5
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-0-3"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-0-3">3</a></span><span>3. tcp_keepalive_time = 1800
</span></span></code></pre></div><h3 id="说说-dns-的解析过程"><strong>说说 DNS 的解析过程？</strong></h3>
<p><strong>思路:</strong> 这道题考察的知识点是 <strong>DNS 域名解析</strong>，http 请求的过程，是涉及到 DNS 域名解析的，这道面试题也挺经典的，大家可以看下《图解 HTTP》那本书哈。</p>
<p>★</p>
<p>DNS，英文全称是 <strong>domain name system</strong>，域名解析系统，是 Internet 上作为域名和 IP 相互映射的一个分布式数据库。它的作用很明确，就是可以根据域名查出对应的 IP 地址。在浏览器缓存、本地 DNS 服务器、根域名服务器都是怎么查找的，大家回答的时候都可以说下哈。</p>
<p>”</p>
<p>DNS 的解析过程如下图：</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-7f57724c1058b99576f01aa357d09e4c.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-7f57724c1058b99576f01aa357d09e4c.png"></p>
<p>DNS 解析查找过程</p>
<p>假设你要查询 <strong><a href="notion://www.notion.so/www.baidu.com">www.baidu.com</a></strong> 的 IP 地址:</p>
<p>★首先会查找浏览器的缓存, 看看是否能找到 <strong><a href="notion://www.notion.so/www.baidu.com">www.baidu.com</a></strong> 对应的 IP 地址，找到就直接返回；否则进行下一步。将请求发往给本地 DNS 服务器，如果查找到也直接返回，否则继续进行下一步；本地 DNS 服务器向<strong>根域名服务器</strong>发送请求，根域名服务器返回负责<code>.com</code>的顶级域名服务器的 IP 地址的列表。本地 DNS 服务器再向其中一个负责<code>.com</code>的顶级域名服务器发送一个请求，返回负责<code>.baidu</code>的权威域名服务器的 IP 地址列表。本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，返回 <strong><a href="notion://www.notion.so/www.baidu.com">www.baidu.com</a></strong> 所对应的 IP 地址。”</p>
<h3 id="聊聊五层计算机网络体系结构中每一层对应的网络协议有哪些"><strong>聊聊五层计算机网络体系结构中，每一层对应的网络协议有哪些？</strong></h3>
<p>为了大家方便记忆，我还是画个思维导图吧，如下：</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-ba1e2d8a01c7492d49d39cb93378550f.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-ba1e2d8a01c7492d49d39cb93378550f.png"></p>
<h3 id="说说-websocket-与-socket-的区别"><strong>说说 WebSocket 与 socket 的区别</strong></h3>
<p><strong>思路:</strong> 这是一个比较基础的知识点，经常有小伙伴会搞混。</p>
<ul>
<li>Socket 其实就是等于 <strong>IP 地址 + 端口 + 协议</strong>。</li>
</ul>
<p>★</p>
<p>具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。</p>
<p>”</p>
<ul>
<li>WebSocket 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决 <strong>http 不支持持久化连接</strong>的问题。</li>
<li>Socket 一个是<strong>网编编程的标准接口</strong>，而 WebSocket 则是应用层通信协议。</li>
</ul>
<h3 id="http-请求的过程与原理"><strong>Http 请求的过程与原理</strong></h3>
<p><strong>思路:</strong> HTTP 请求，一个非常非常基础的知识点，一定需要掌握的。其实觉得跟浏览器地址栏输入 url 到显示主页这道题有点类似。</p>
<p><strong>我的答案如下</strong>：</p>
<p>HTTP 是一个基于 TCP/IP 协议来传递数据的超文本传输协议，传输的数据类型有 HTML, 图片等。以访问百度有例子，看下一次 Http 的请求过程吧</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-d58966fe4854169509511d6bfc90de9d.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-d58966fe4854169509511d6bfc90de9d.png"></p>
<p>Http 请求过程</p>
<ol>
<li>客户端进行 DNS 域名解析，得到对应的 IP 地址</li>
<li>根据这个 IP，找到对应的服务器建立连接（三次握手）</li>
<li>建立 TCP 连接后发起 HTTP 请求（一个完整的 http 请求报文）</li>
<li>服务器响应 HTTP 请求，客户端得到 html 代码</li>
<li>客户端解析 html 代码，用 html 代码中的资源 (如 js,css, 图片等等) 渲染页面。</li>
<li>服务器关闭 TCP 连接（四次挥手）</li>
</ol>
<h3 id="ip-地址有哪些分类"><strong>IP 地址有哪些分类？</strong></h3>
<p>一般可以这么认为，IP 地址 = 网络号 + 主机号。</p>
<ol>
<li>网络号：它标志主机所连接的网络地址表示属于互联网的哪一个网络。</li>
<li>主机号：它标志主机地址表示其属于该网络中的哪一台主机。</li>
</ol>
<p>IP 地址分为 A，B，C，D，E 五大类：</p>
<ul>
<li>A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位。</li>
<li>B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位。</li>
<li>C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位。</li>
<li>D 类地址 (224~239)：以 1110 开头，保留位多播地址。</li>
<li>E 类地址 (240~255)：以 11110 开头，保留位为将来使用</li>
</ul>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-faa187d21caaf4e7283eb57118ab21dc.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-faa187d21caaf4e7283eb57118ab21dc.png"></p>
<p>IP 地址分类</p>
<h3 id="说下-arp-协议的工作过程"><strong>说下 ARP 协议的工作过程？</strong></h3>
<ul>
<li>
<p>原回答</p>
<p>ARP 协议协议，<strong>Address Resolution Protocol</strong>，地址解析协议，它是用于实现 IP 地址到 MAC 地址的映射。</p>
<p>★首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的 ARP 列表，是否存在该 IP 地址对应的 MAC 地址；如果有﹐就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求的数据包里，包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。”</p>
</li>
<li>
<p>我的回答</p>
<p>先回答arp是什么</p>
<ul>
<li>arp有一个缓存arp表，是ip到MAC得缓存映射表。</li>
<li>具体得流程呢，比如在一个以太网内，A主机给B主机发送信息，由于是链路层，所以通过MAC地址去发送。我们首先会检查arp表是否有映射，有的话，直接发送。</li>
<li>如果没有映射，我们会构造一个ARP分组，包含发送方得IP和MAC地址，还有接受方的IP。然后用MAC广播地址（FF-FF-FF-FF-FF-FF）来发送这个分组。然后所有的主机都会收到这个分组，匹配是否ip是否一致，如果一致的主机会单播返回“响应ARP分组”。然后ARP表会更新缓存映射数据。并发送数据。</li>
</ul>
</li>
</ul>
<h3 id="什么是arp呢">什么是arp呢？</h3>
<p>因为存在网络层地址（例如，因特网的IP地址）和链路层那地址  （即MAC地址），所以需要在它们之间进行转换。对于因特网而言，这是地址解析协议（Address Resolution Protocol,ARP）的任务</p>
<ol>
<li>2 arp使用得场景</li>
</ol>
<ul>
<li>局域网发送数据</li>
<li>第一次获取dhcp ip</li>
</ul>
<h3 id="有了-ip-地址为什么还要用-mac-地址"><strong>有了 IP 地址，为什么还要用 MAC 地址？</strong></h3>
<ul>
<li>
<p>原回答</p>
<p>★简而言之，标识网络中的一台计算机，比较常用的就是 <strong>IP 地址和 MAC 地址</strong>，但计算机的 IP 地址可由用户自行更改，管理起来就相对困难，而 MAC 地址不可更改，所以一般会把 IP 地址和 MAC 地址组合起来使用。</p>
<p>那只使用 MAC 地址不用 IP 地址行不行呢？不行的！因为最早就是 MAC 地址先出现的，并且当时并不用 IP 地址，只用 MAC 地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可。</p>
<p>那为什么要用 IP 地址呢？是因为 IP 地址是和地域相关的，对于同一个子网上的设备，IP 地址的前缀都是一样的，这样路由器通过 IP 地址的前缀就知道设备在在哪个子网上了，而只用 MAC 地址的话，路由器则需要记住每个 MAC 地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。</p>
<p>IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。”</p>
</li>
<li>
<p>我的回答</p>
<ul>
<li>保持网络层与链路层互相独立，这样能适应更多的场景。
<ul>
<li>比如局域网是为任意网络层协议设计的，而不只是ip与因特网</li>
</ul>
</li>
<li>说明ip协议的作用</li>
<li>说明MAC地址的作用</li>
<li>总结，所以还需要IP地址。不如以太网就需要MAC地址来传输</li>
</ul>
</li>
</ul>
<h3 id="tcp-和-udp-分别对应的常见应用层协议有哪些"><strong>TCP 和 UDP 分别对应的常见应用层协议有哪些？</strong></h3>
<p><strong>基于 TCP 的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH</strong></p>
<ul>
<li><strong>HTTP</strong>：HyperText Transfer Protocol（超文本传输协议），默认端口 80</li>
<li><strong>FTP</strong>: File Transfer Protocol (文件传输协议), 默认端口 (20 用于传输数据，21 用于传输控制信息)</li>
<li><strong>SMTP</strong>: Simple Mail Transfer Protocol (简单邮件传输协议) , 默认端口 25</li>
<li><strong>TELNET</strong>: Teletype over the Network (网络电传), 默认端口 23</li>
<li><strong>SSH</strong>：Secure Shell（安全外壳协议），默认端口 22</li>
</ul>
<p><strong>基于 UDP 的应用层协议：DNS、TFTP、SNMP</strong></p>
<ul>
<li><strong>DNS</strong> : Domain Name Service (域名服务), 默认端口 53</li>
<li><strong>TFTP</strong>: Trivial File Transfer Protocol (简单文件传输协议)，默认端口 69</li>
<li><strong>SNMP</strong>：Simple Network Management Protocol（简单网络管理协议），通过 UDP 端口 161 接收，只有 Trap 信息采用 UDP 端口 162。</li>
</ul>
<h3 id="聊聊保活计时器的作用"><strong>聊聊保活计时器的作用</strong></h3>
<p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
<ul>
<li>TCP 四次挥手</li>
</ul>
<h3 id="如果服务器出现了大量-close_wait-状态如何解决"><strong>如果服务器出现了大量 CLOSE_WAIT 状态如何解决。</strong></h3>
<p>就是服务器没有调用或没有及时调用close()；</p>
<p>我们先来复习下 TCP 的四次挥手</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-44ee0cb73ea8397feb1977d138f8f995.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-44ee0cb73ea8397feb1977d138f8f995.png"></p>
<ul>
<li>服务器端收到客户端发送的<code>FIN</code>后，TCP 协议栈就会自动发送 ACK，接着进入 <strong>CLOSE_WAIT</strong> 状态。</li>
<li>但是如果服务器端不执行 socket 的 close() 操作，那么就没法进入 LAST_ACK, 导致大量连接处于 CLOSE_WAIT 状态</li>
<li>所以，如果服务器出现了大量 <strong>CLOSE_WAIT</strong> 状态，一般是程序 Bug，或者关闭 socket 不及时。</li>
</ul>
<p>31.1 TCP三次握手详情</p>
<ul>
<li>客户端发送请求报文，报文包含随机序号、SYN状态为1发送给服务器</li>
<li>服务器返回确认报文，报文包含随机需要，SYN状态为1，确认号（随机序号+1），并建立变量和缓存</li>
<li>客户端接收后，建立自己的变量和缓存。这个时候连接已经建立了，第三次就可以携带数据了。发送的报文包含（SYN状态为0，序号和数据）</li>
</ul>
<p>31.2 TCP为什么会有三次握手</p>
<ul>
<li>
<p>因为这个是最小的握手次数。就像我们打电话一样。具体描述吧</p>
</li>
<li>
<p>具体原因呢，两次握手有问题。比如第一次握手，由于网络阻塞了，发送了两次，那服务器就会建立两次连接，而客户端确只有一次。所以两次不行</p>
</li>
<li>
<p>四次呢，没有太大的意义，所以就3次</p>
</li>
<li>
<p>什么时候出现大量TIME_wait, 以及如何解决服务器的处理</p>
<p>服务器挂了或重启，导致服务器出现time_wait;</p>
<ol>
<li>等待2MLS后重启服务器</li>
<li>添加so_reuseaddr- &gt; SO_REUSEADDR是让端口释放后立即就可以被再次使用</li>
</ol>
</li>
<li>
<p>出现大量close_wait导致什么影响</p>
<p>所以当有大量CLOSE WAIT的时候会占用服务器的fd。而一个机器能打开的fd数量是有限的。超过了，因为无法分配fd，就无法建立新连接啦</p>
</li>
<li>
<p><strong><strong>怎么避免客户端异常断开时的服务端CLOSE_WAIT？</strong></strong></p>
<p>有一人方法。比如我用了epoIl，那么我监听客户端连接套接字（5）的EPOLLRDHUP这个事件。当客户端意外断开时，这人事件就会被触发，触发之后。我们针对性的对这人fd（5）执行closeO操作就可以了。</p>
<p>参考：<a href="https://www.zhihu.com/question/298214130">https://www.zhihu.com/question/298214130</a></p>
</li>
</ul>
<h3 id="uri-和-url-的区别"><strong>URI 和 URL 的区别</strong></h3>
<ul>
<li>URI，全称是 Uniform Resource Identifier)，中文翻译是统一资源标志符，主要作用是唯一标识一个资源。</li>
<li>URL，全称是 Uniform Resource Location)，中文翻译是统一资源定位符，主要作用是提供资源的路径。打个经典比喻吧，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人。</li>
</ul>
<h3 id="icmp-协议的功能"><strong>ICMP 协议的功能</strong></h3>
<p>ICMP,Internet Control Message Protocol ,Internet 因特网控制消息协议。</p>
<ul>
<li>ICMP 协议是一种面向无连接的协议，用于传输出错报告控制信息。</li>
<li>它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括<strong>报告错误、交换受限控制和状态信息</strong>等。</li>
<li>当遇到 IP 数据无法访问目标、IP 路由器无法按当前的传输速率转发数据包等情况时，会自动发送 ICMP 消息。</li>
</ul>
<p>比如我们日常使用得比较多的 <strong>ping</strong>，就是基于 ICMP 的。</p>
<h3 id="说下-ping-的原理"><strong>说下 ping 的原理</strong></h3>
<p>★</p>
<p>ping，<strong>Packet Internet Groper</strong>，是一种因特网包探索器，用于测试网络连接量的程序。Ping 是工作在 TCP/IP 网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态</p>
<p>”</p>
<p>一般来说，ping 可以用来检测网络通不通。它是基于<code>ICMP</code>协议工作的。假设<strong>机器 A</strong> ping <strong>机器 B</strong>，工作过程如下：</p>
<ol>
<li>ping 通知系统，新建一个固定格式的 ICMP 请求数据包</li>
<li>ICMP 协议，将该数据包和目标机器 B 的 IP 地址打包，一起转交给 IP 协议层</li>
<li>IP 层协议将本机 IP 地址为源地址，机器 B 的 IP 地址为目标地址，加上一些其他的控制信息，构建一个 IP 数据包</li>
<li>先获取目标机器 B 的 MAC 地址。</li>
<li>数据链路层构建一个数据帧，目的地址是 IP 层传过来的 <strong>MAC 地址</strong>，源地址是本机的 <strong>MAC 地址</strong></li>
<li>机器 B 收到后，对比目标地址，和自己本机的 MAC 地址是否一致，符合就处理返回，不符合就丢弃。</li>
<li>根据目的主机返回的 ICMP 回送回答报文中的时间戳，从而计算出往返时间</li>
<li>最终显示结果有这几项：发送到目的主机的 IP 地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小、最大 &amp; 平均值</li>
</ol>
<h3 id="请详细介绍一下-tcp-的三次握手机制"><strong>请详细介绍一下 TCP 的三次握手机制</strong></h3>
<p><strong>思路:</strong> TCP 连接的三次握手机制，最重要的知识点，必须得会，通讯过程以及客户端、服务器的对应的状态都需要记住哈。</p>
<p>TCp 提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的就是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。我们一起来看下流程图哈：</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-eaaf3fdfd9c7a2b0390fa7a7973f2218.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-eaaf3fdfd9c7a2b0390fa7a7973f2218.png"></p>
<p>TCP 三次握手</p>
<ul>
<li>第一次握手 (SYN=1, seq=x)，发送完毕后，客户端就进入 SYN_SEND 状态</li>
<li>第二次握手 (SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端就进入 SYN_RCV 状态。</li>
<li>第三次握手 (ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态。</li>
</ul>
<h3 id="tcp-握手为什么是三次为什么不能是两次不能是四次"><strong>TCP 握手为什么是三次，为什么不能是两次？不能是四次？</strong></h3>
<p><strong>思路:</strong> TCP 握手为什么不能是两次，为什么不能是四次呢？为了方便理解，我们以男孩子和女孩子谈恋爱为例子：两个人能走到一起，最重要的事情就是相爱，就是<strong>我爱你，并且我知道，你也爱我</strong>，接下来我们以此来模拟三次握手的过程：</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-f795189dd1254b2b5765b0a617198b9c.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-f795189dd1254b2b5765b0a617198b9c.png"></p>
<p><strong>为什么握手不能是两次呢？</strong></p>
<p>如果只有两次握手，女孩子可能就不知道，她的那句<strong>我也爱你</strong>，男孩子是否<strong>收到</strong>，恋爱关系就不能愉快展开。</p>
<p><strong>为什么握手不能是四次呢？</strong></p>
<p>因为握手不能是四次呢？因为三次已经够了，三次已经能让双方都知道：你爱我，我也爱你。而四次就多余了。</p>
<h3 id="说说-tcp-四次挥手过程"><strong>说说 TCP 四次挥手过程</strong></h3>
<p><strong>思路:</strong> TCP 的四次挥手，也是最重要的知识点，一般跟三次握手会一起考的，必须得记住。</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-8d9d9e5c274d6b4cc3deb1767d67d1f8.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-8d9d9e5c274d6b4cc3deb1767d67d1f8.png"></p>
<p>TCP 四次挥手过程</p>
<ol>
<li>第一次挥手 (FIN=1，seq=u)，发送完毕后，客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
<li>第二次挥手 (ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入 <strong>CLOSE_WAIT</strong> 状态，客户端接收到这个确认包之后，进入 <strong>FIN_WAIT_2</strong> 状态。</li>
<li>第三次挥手 (FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入 <strong>LAST_ACK</strong> 状态，等待来自客户端的最后一个 ACK。</li>
<li>第四次挥手 (ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，<strong>等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后</strong>，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li>
</ol>
<h3 id="tcp-挥手为什么需要四次呢"><strong>TCP 挥手为什么需要四次呢？</strong></h3>
<ul>
<li>
<p><strong>连接终止协议（四次挥手）</strong></p>
<p><strong>2、连接终止协议（四次挥手）</strong></p>
<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送（报文段4）。</p>
<p>（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。</p>
<p>（3） 服务器关闭客户端的连接，发送一个FIN给客户端（报文段6）。</p>
<p>（4） 客户段发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。</p>
</li>
<li>
<p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p>
<p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
</li>
</ul>
<h3 id="tcp-四次挥手过程中为什么需要等待-2msl-才进入-closed-关闭状态"><strong>TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态</strong></h3>
<p><strong>思路：</strong> 这个<strong>问得频率特别高</strong>。去面试前，一定要把这道题拿下哈。</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-44ee0cb73ea8397feb1977d138f8f995.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-44ee0cb73ea8397feb1977d138f8f995.png"></p>
<p>2MSL，<strong>two Maximum Segment Lifetime</strong>，即两个最大段生命周期。假设<strong>主动发起挥手的是客户端</strong>，那么需要 2MSL 的原因是：</p>
<p>★<strong>1. 为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</strong> 这个 ACK 报文段有可能丢失，因而使处在 <strong>LAST-ACK</strong> 状态的服务端就收不到对已发送的 <strong>FIN + ACK</strong> 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 <strong>CLOSED</strong> 状态。<strong>2. 防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。”</p>
<ul>
<li>
<p><strong><strong>tcp连接中，服务端主动断开连接</strong></strong></p>
<p>上图发生的原因是这样的，当服务器进程被终止时，会关闭其打开的所有文件描述符，此时就会向客户端发送一个FIN 的报文,客户端则响应一个ACK 报文,但是这样只完成了“四次挥手”的前两次挥手，也就是说这样只实现了半关闭，客户端仍然可以向服务器写入数据。
但是当客户端向服务器写入数据时，由于服务器端的套接字进程已经终止，此时连接的状态已经异常了，所以服务端进程不会向客户端发送ACK 报文，而是发送了一个RST 报文请求将处于异常状态的连接复位； 如果客户端此时还要向服务端发送数据，将诱发服务端TCP向服务端发送SIGPIPE信号，因为向接收到RST的套接口写数据都会收到此信号. 所以说，这就是为什么我们主动关闭服务端后，用客户端向服务端写数据，还必须是写两次后连接才会关闭的原因。</p>
<p>大家可以在自己的Linux系统实验一下，用tcpdump去抓包效果会更好。</p>
</li>
</ul>
<h3 id="tcp-的粘包和拆包"><strong>TCP 的粘包和拆包</strong></h3>
<p>TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一<strong>个完整的包可能会被 TCP 拆分成多个包进行发送</strong>，<strong>也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是所谓的 TCP 粘包和拆包问题。</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-8dec9e57094f083991b19a6ba95c49fe.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-8dec9e57094f083991b19a6ba95c49fe.png"></p>
<p>TCP 的粘包和拆包</p>
<p><strong>为什么会产生粘包和拆包呢?</strong></p>
<ul>
<li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li>
<li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；</li>
<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>发送端将每个数据包封装为固定长度</li>
<li>在数据尾部增加特殊字符进行分割</li>
<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li>
</ul>
<h3 id="聊聊-tcp-的流量控制"><strong>聊聊 TCP 的流量控制</strong></h3>
<p>TCP 三次握手，发送端和接收端进入到 ESTABLISHED 状态，它们即可以愉快地传输数据啦。</p>
<p>但是发送端不能疯狂地向接收端发送数据，因为接收端接收不过来的话，接收方只能把处理不过来的数据存在缓存区里。如果缓存区都满了，发送方还在疯狂发送数据的话，接收方只能把收到的数据包丢掉，这就浪费了网络资源啦。</p>
<p>★</p>
<p>TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是<strong>流量控制</strong>。</p>
<p>”</p>
<p>TCP 通过滑动窗口来控制流量，我们看下流量控制的<strong>简要流程</strong>吧：</p>
<p>首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-8f6389c120734508b1e3367a8a8c4d9f.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-8f6389c120734508b1e3367a8a8c4d9f.png"></p>
<p>TCP 的流量控制</p>
<ol>
<li>假如当前发送方给接收方发送了 200 个字节，那么，发送方的<code>SND.NXT</code>会右移 200 个字节，也就是说当前的可用窗口减少了 200 个字节。</li>
<li>接受方收到后，放到缓冲队列里面，REV.WND =400-200=200 字节，所以 win=200 字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口 200 字节</li>
<li>发送方又发送 200 字节过来，200 字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理 100 字节，剩余的 100 字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100 字节，即 win=100 返回发送方。</li>
<li>发送方继续干活，发送 100 字节过来，这时候，接受窗口 win 变为 0。</li>
<li>发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win 大于 0，才继续开始发送。</li>
</ol>
<h3 id="说说半连接队列和-syn-flood-攻击的关系"><strong>说说半连接队列和 SYN Flood 攻击的关系</strong></h3>
<p><strong>思路讲解：</strong> 我以前面试的时候，面试官就问我什么是半连接队列、什么是全连接队列，哈哈。我们需要掌握半连接队列、全连接对列是啥，还需要清楚半连接队列和 SYN Flood 攻击有什么关系。</p>
<p><strong>我的答案如下：</strong></p>
<p>TCP 进入三次握手前，服务端会从 <strong>CLOSED</strong> 状态变为 <strong>LISTEN</strong> 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p>
<p>什么是<strong>半连接队列（SYN 队列）</strong> 呢? 什么是<strong>全连接队列（ACCEPT 队列）</strong> 呢？回忆下 TCP 三次握手的图：</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-7038b6e7d52a9cc580b6071a705ad61a.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-7038b6e7d52a9cc580b6071a705ad61a.png"></p>
<p>三次握手</p>
<ul>
<li>TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 <strong>ACK 和 SYN</strong>，状态由 <strong>LISTEN 变为 SYN_RCVD</strong>，此时这个连接就被推入了 <strong>SYN 队列</strong>，即半连接队列。</li>
<li>当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。</li>
</ul>
<p>SYN Flood 是一种典型的 DDos 攻击，它在短时间内，伪造<strong>不存在的 IP 地址</strong>, 向服务器大量发起 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，导致服务器上建立大量的半连接半连接队列满了，这就无法处理正常的 TCP 请求啦。</p>
<p>那么有哪些方案应对呢？主要有 <strong>syn cookie</strong> 和 <strong>SYN Proxy 防火墙</strong>等。</p>
<p>★<strong>syn cookie</strong>：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。<strong>SYN Proxy 防火墙</strong>：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。”</p>
<h3 id="聊聊-tcp-的滑动窗口"><strong>聊聊 TCP 的滑动窗口</strong></h3>
<p><strong>思路讲解：</strong> TCP 滑动窗口是个高频考点，我们需要知道 TCP 报文首部有个字段 <strong>win</strong> 控制窗口大小的，同时也需要掌握，滑动窗口是怎么滑的。</p>
<p>TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。</p>
<p>★</p>
<p>这就好像我们面对面在聊天，你说完一句，我应答之后，你才能说下一句。那么，如果我在忙其他事情，没有能够及时回复你呢？你说完一句后，要等到我忙完回复你，你才说下句，这显然不现实，效率太低。</p>
<p>”</p>
<p>为了解决这个问题，TCP 引入了<strong>窗口</strong>，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。</p>
<p>TCP 头部有个字段叫 win，也即那个 <strong>16 位的窗口大小</strong>，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到<strong>流量控制</strong>的目的。</p>
<p>★</p>
<p>通俗点讲，就是接受方每次收到数据包，在发送确认报文的时候，同时告诉发送方，自己的缓存区还有多少空余空间，缓冲区的空余空间，我们就称之为接受窗口大小。这就是 win。</p>
<p>”</p>
<p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。<strong>发送端的滑动窗口</strong>包含四大部分，如下：</p>
<ul>
<li>已发送且已收到 ACK 确认</li>
<li>已发送但未收到 ACK 确认</li>
<li>未发送但可以发送</li>
<li>未发送也不可以发送</li>
</ul>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-ae709e0823e9e85ae50a98d6254ef491.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-ae709e0823e9e85ae50a98d6254ef491.png"></p>
<ul>
<li>虚线矩形框，就是发送窗口。</li>
<li>SND.WND: 表示发送窗口的大小, 上图虚线框的格子数是 14 个，即发送窗口大小是 14。</li>
<li>SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。</li>
<li>SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</li>
</ul>
<p>接收方的滑动窗口包含三大部分，如下：</p>
<ul>
<li>已成功接收并确认</li>
<li>未收到数据但可以接收</li>
<li>未收到数据并不可以接收的数据</li>
</ul>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-886a4ca16926fd89d193095a8c6ccb5f.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-886a4ca16926fd89d193095a8c6ccb5f.png"></p>
<ul>
<li>虚线矩形框，就是接收窗口。</li>
<li>REV.WND: 表示接收窗口的大小, 上图虚线框的格子就是 9 个。</li>
<li>REV.NXT: 下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。</li>
</ul>
<h3 id="tcp-的拥塞控制"><strong>TCP 的拥塞控制</strong></h3>
<p><strong>思路讲解：</strong> TCP 拥塞机制也是个高频考点，需要掌握<strong>它跟流量控制</strong>的区别，也需要掌握拥塞控制的这几种算法：<strong>慢启动算法、拥塞避免、拥塞发生、快速恢复算法</strong>。</p>
<p>拥塞控制是<strong>作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况</strong>。它的目标主要是最大化利用网络上瓶颈链路的带宽。它跟<strong>流量控制</strong>又有什么区别呢？流量控制是作用于接收者的，根据<strong>接收端的实际接收能力控制发送速度</strong>，防止分组丢失的。</p>
<p>我们可以把网络链路比喻成一根水管，如果我们想最大化利用网络来传输数据，那就是尽快让水管达到最佳充满状态。</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-e05ea7c279a7308a5bc041dbab7152f6.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-e05ea7c279a7308a5bc041dbab7152f6.png"></p>
<p>发送方维护一个<strong>拥塞窗口 cwnd（congestion window）</strong> 的变量，用来估算在一段时间内这条链路（水管）可以承载和运输的数据（水）的数量。它大小代表着网络的拥塞程度，并且是动态变化的，但是为了达到最大的传输效率，我们该如何知道这条水管的运送效率是多少呢？</p>
<p>一个比较简单的方法就是不断增加传输的水量，直到水管快要爆裂为止（对应到网络上就是发生丢包），用 TCP 的描述就是：</p>
<p>★</p>
<p>只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。</p>
<p>”</p>
<p>实际上，拥塞控制主要有这几种常用算法</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h3 id="慢启动算法"><strong>慢启动算法</strong></h3>
<p>慢启动算法，表面意思就是，别急慢慢来。它表示 TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，<strong>每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）</strong>。<strong>每轮次</strong>发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。</p>
<ul>
<li>TCP 连接完成，初始化 cwnd = 1，表明可以传一个 MSS 单位大小的数据。</li>
<li>每当收到一个 ACK，cwnd 就加一;</li>
<li>每当过了一个 RTT，cwnd 就增加一倍; 呈指数让升</li>
</ul>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-8b9d6208fc78c82a044d96f57d5ff787.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-8b9d6208fc78c82a044d96f57d5ff787.png"></p>
<p>为了防止 cwnd 增长过大引起网络拥塞，还需设置一个<strong>慢启动阀值 ssthresh</strong>（slow start threshold）状态变量。当<code>cwnd</code>到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当 <strong>cwnd &gt;ssthresh</strong> 时，进入了<strong>拥塞避免</strong>算法。</p>
<h3 id="拥塞避免算法"><strong>拥塞避免算法</strong></h3>
<p>一般来说，慢启动阀值 ssthresh 是 65535 字节，<code>cwnd</code>到达<strong>慢启动阀值</strong>后</p>
<ul>
<li>每收到一个 ACK 时，cwnd = cwnd + 1/cwnd</li>
<li>当每过一个 RTT 时，cwnd = cwnd + 1</li>
</ul>
<p>显然这是一个线性上升的算法，避免过快导致网络拥塞问题。</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-0bce7b07782db19233b98cdd54ed6121.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-0bce7b07782db19233b98cdd54ed6121.png"></p>
<h3 id="拥塞发生"><strong>拥塞发生</strong></h3>
<p>当网络拥塞发生<strong>丢包</strong>时，会有两种情况：</p>
<ul>
<li>RTO 超时重传</li>
<li>快速重传</li>
</ul>
<p>如果是发生了 <strong>RTO 超时重传</strong>，就会使用拥塞发生算法</p>
<ul>
<li>慢启动阀值 sshthresh = cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入新的慢启动过程</li>
</ul>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-373e0f394792af9c44face0f2852abff.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-373e0f394792af9c44face0f2852abff.png"></p>
<p>这真的是<strong>辛辛苦苦几十年，一朝回到解放前</strong>。其实还有更好的处理方式，就是<strong>快速重传</strong>。发送方收到 3 个连续重复的 ACK 时，就会快速地重传，不必等待 <strong>RTO 超时</strong>再重传。</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-311271a6e184c49c37a2e3b2bfd9af61.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-311271a6e184c49c37a2e3b2bfd9af61.png"></p>
<p>image.png</p>
<p>慢启动阀值 ssthresh 和 cwnd 变化如下：</p>
<ul>
<li>拥塞窗口大小 cwnd = cwnd/2</li>
<li>慢启动阀值 ssthresh = cwnd</li>
<li>进入快速恢复算法</li>
</ul>
<h3 id="快速恢复"><strong>快速恢复</strong></h3>
<p>快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。</p>
<p>正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-1-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-1-1">1</a></span><span>- cwnd = cwnd /2
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-1-2"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-1-2">2</a></span><span>- sshthresh = cwnd
</span></span></code></pre></div><p>然后，真正的快速算法如下：</p>
<ul>
<li>cwnd = sshthresh + 3</li>
<li>重传重复的那几个 ACK（即丢失的那几个数据包）</li>
<li>如果再收到重复的 ACK，那么 cwnd = cwnd +1</li>
<li>如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。</li>
</ul>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-8537366c7623840fd7065dd671ddbe40.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-8537366c7623840fd7065dd671ddbe40.png"></p>
<h3 id="说说-tcp-是如何确保可靠性的呢"><strong>说说 TCP 是如何确保可靠性的呢？</strong></h3>
<p><strong>思路：</strong> TCP 是可靠的连接，为什么具有可靠性呢？记住这些点：连接和断开的可靠性（三次握手，四次挥手）、有状态（哪些数据发送了，哪些没发）、可控制（超时重传、流量控制、拥塞控制等）。</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-40cdc0971e2f18c22df708ddeca79ade.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-40cdc0971e2f18c22df708ddeca79ade.png"></p>
<ul>
<li>首先，TCP 的连接是基于<strong>三次握手</strong>，而断开则是基于<strong>四次挥手</strong>。确保连接和断开的可靠性。</li>
<li>其次，TCP 的可靠性，还体现在<strong>有状态</strong>;TCP 会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。</li>
<li>再次，TCP 的可靠性，还体现在<strong>可控制</strong>。它有数据包校验、ACK 应答、<strong>超时重传 (发送方)</strong>、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。</li>
</ul>
<h3 id="说说-tcp-报文首部有哪些字段其作用又分别是什么"><strong>说说 TCP 报文首部有哪些字段，其作用又分别是什么？</strong></h3>
<p><strong>思路：</strong> 小伙伴们，可以记下这个图。</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-cf87753017b42de921f71c11746cc6cf.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-cf87753017b42de921f71c11746cc6cf.png"></p>
<ul>
<li><strong>16 位端口号</strong>：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序</li>
<li><strong>32 位序号</strong>：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。</li>
<li><strong>32 位确认号</strong>：用作对另一方发送的 tcp 报文段的响应。其值是收到的 TCP 报文段的序号值加 1。</li>
<li><strong>4 位头部长度</strong>：表示 tcp 头部有多少个 32bit 字（4 字节）。因为 4 位最大能标识 15，所以 TCP 头部最长是 60 字节。</li>
<li><strong>6 位标志位</strong>：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）</li>
<li><strong>16 位窗口大小</strong>：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li>
<li><strong>16 位校验和</strong>：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。</li>
<li><strong>16 位紧急指针</strong>：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</li>
</ul>
<h3 id="说说-tcp-的重传机制"><strong>说说 TCP 的重传机制</strong></h3>
<p><strong>思路讲解：</strong> TCP 的重传机制，也是道非常高频的面试题。重传包括<strong>超时重传、快速重传、带选择确认的重传（SACK）、重复 SACK 四种</strong>。</p>
<h3 id="501-超时重传"><strong>50.1 超时重传</strong></h3>
<p>超时重传，是 TCP 协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的 ACK 报文，那么就重新发送数据，直到发送成功为止。</p>
<p>这个一定时间内，一般是多少比较合理呢？来看下什么叫 <strong>RTT（Round-Trip Time，往返时间）</strong>。</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-69f6f681275c215367e3018831d76ac8.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-69f6f681275c215367e3018831d76ac8.png"></p>
<p>RTT 就是数据完全发送完，到收到确认信号的时间，即数据包的一次往返时间。超时重传时间，就是 RTO（Retransmission Timeout)。</p>
<p>那么，<strong>RTO 到底设置多大呢？</strong></p>
<ul>
<li>如果 RTO 设置很大，等了很久都没重发，这样肯定就不行。</li>
<li>如果 RTO 设置很小，那很可能数据都没有丢失，就开始重发了，这会导致网络阻塞，从而恶性循环，导致更多的超时出现。</li>
</ul>
<p>一般来说，RTO 略微大于 RTT，效果是最佳的。其实，RTO 有个标准方法的计算公式，也叫 <strong>Jacobson / Karels 算法</strong>。一起来看下吧：</p>
<p><strong>1. 首先计算 SRTT（即计算平滑的 RTT）</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-2-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-2-1">1</a></span><span>SRTT = (1 - α) * SRTT + α * RTT  //求 SRTT 的加权平均
</span></span></code></pre></div><p><strong>2. 其次，计算 RTTVAR (round-trip time variation)</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-3-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-3-1">1</a></span><span>RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) //计算 SRTT 与真实值的差距
</span></span></code></pre></div><p><strong>3. 最后，得出最终的 RTO</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-4-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-4-1">1</a></span><span>RTO = µ * SRTT + ∂ * RTTVAR  =  SRTT + 4·RTTVAR
</span></span></code></pre></div><p>一般情况，α、β等的参数取值如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-5-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-5-1">1</a></span><span>α = 0.125，β = 0.25， μ = 1，∂ = 4
</span></span></code></pre></div><p>别问这些参数是怎么来的，它们是大量实践，调出的最优参数。</p>
<p>超时重传不是十分完美的重传方案，它有这些缺点：</p>
<p>★当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。”</p>
<p>并且，对于 TCP，如果发生一次超时重传，时间间隔下次就会加倍。</p>
<h3 id="502-快速重传"><strong>50.2 快速重传</strong></h3>
<p>其实可以使用<strong>快速重传</strong>，来解决超时重发的时间等待问题。它不以时间驱动，而是以数据驱动。它是基于接收端的反馈信息来引发重传的。快速重传流程如下：</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-fc905a42c5917b66a1d9476b7fa1e71b.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-fc905a42c5917b66a1d9476b7fa1e71b.png"></p>
<p>快速重传流程</p>
<p>发送方发送了 1，2，3，4，5,6 份数据:</p>
<ul>
<li>第一份 Seq=1 先送到了，于是就 Ack 回 2；</li>
<li>第二份 Seq=2 也送到了，于是 ACK 回 3；</li>
<li>第三份 Seq=3 由于网络等某些原因，没送到；</li>
<li>第四份 Seq=4 送到了，但是由于 Seq=3 没收到。因此 ACK 还是回 3；</li>
<li>后面的 Seq=5,6 的也送到了，ACK 还是回复 3，因为 Seq=3 没有收到。</li>
<li>发送方连着收到三个重复冗余 ACK=3 的确认（其实是 4 个哈，但是因为前面的一个是正常的 ACK，后面三个才是重复冗余的），于是知道哪个报文段在传输过程中丢失了；发送方在定时器过期之前，重传该报文段。</li>
<li>最后，接收方收到了 Seq=3，此时因为 Seq=4，5，6 都收到了，于是它回 ACK=7。</li>
</ul>
<p>但是呢，<strong>快速重传</strong>也可能有问题：ACK 只向告知发送方，最大的有序报文段。到底是哪个报文丢失了呢？<strong>并不确定</strong>！那到底该重传多少个包呢？</p>
<p>★</p>
<p>是重传 Seq=3 ？还是重传 Seq=3、Seq=4、Seq=5、Seq=6 呢？因为发送端并不清楚这三个连续的 ACK=3 是谁传回来的。</p>
<p>”</p>
<h3 id="503-带选择确认的重传sack"><strong>50.3 带选择确认的重传（SACK）</strong></h3>
<p>为了解决：<strong>应该重传多少个包</strong>的问题? TCP 提供了<strong>带选择确认的重传</strong>（即 SACK，Selective Acknowledgment）。</p>
<p>★</p>
<p><strong>SACK 机制</strong>就是，在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包啦。</p>
<p>”</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-2f299dcc517551ba3f3e2da95457e661.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-2f299dcc517551ba3f3e2da95457e661.png"></p>
<p>SACK 机制</p>
<p>如上图中，发送方收到了三次同样的 ACK=30 的确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有<code>30~39</code>这段数据丢失，于是重发时，就只选择了这个<code>30~39</code>的 TCP 报文段进行重发。</p>
<h3 id="504-重复-sackd-sack"><strong>50.4 重复 SACK（D-SACK）</strong></h3>
<p>★</p>
<p>D-SACK，英文是 Duplicate SACK，是在 SACK 的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。来看个图吧：</p>
<p>”</p>
<p><img src="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-597f59d6bb0af8567da78be599e27ddc.png" alt="http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-597f59d6bb0af8567da78be599e27ddc.png"></p>
<p>D-SACK 简要流程</p>

        </div>

        
        
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">啊沉</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2023-06-01
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>



        
        


        <footer class="post-footer">
          


          
          <nav class="post-nav">
            
              <a class="prev" href="/post/j-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
                
                <i class="iconfont">
                  <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

                </i>
                <span class="prev-text nav-default">一些共同场景问题解决方式</span>
                <span class="prev-text nav-mobile">Prev</span>
              </a>
            
              <a class="next" href="/post/y-%E8%BF%90%E7%BB%B4/docker/docker-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E5%AE%B9%E5%99%A8%E9%97%B4%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">
                <span class="next-text nav-default">Docker 跨主机容器间网络通信</span>
                <span class="prev-text nav-mobile">Next</span>
                
                <i class="iconfont">
                  <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

                </i>
              </a>
          </nav>
        </footer>
      </article>

      
      


      
      

  

  
  

  
  

  

  

    

  

  


    </div>

    
    <nav class="toc" id="toc">
    <div class="toc-title">Table of Contents</div>
    <div class="toc-content custom-scrollbar">
      <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#请简述-tcp-和-udp-的区别"><strong>请简述 TCP 和 UDP 的区别</strong></a></li>
        <li><a href="#请简单说一下你了解的端口及对应的服务"><strong>请简单说一下你了解的端口及对应的服务？</strong></a></li>
        <li><a href="#说下计算机网络体系结构"><strong>说下计算机网络体系结构</strong></a></li>
        <li><a href="#iso-七层模型"><strong>ISO 七层模型</strong></a></li>
        <li><a href="#tcpip-四层模型"><strong>TCP/IP 四层模型</strong></a></li>
        <li><a href="#五层体系结构"><strong>五层体系结构</strong></a></li>
        <li><a href="#从浏览器地址栏输入-url-到显示主页的过程"><strong>从浏览器地址栏输入 url 到显示主页的过程</strong></a></li>
        <li><a href="#在交互过程中如果数据传送完了还不想断开连接怎么办怎么维持"><strong>在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</strong></a></li>
        <li><a href="#http-如何实现长连接在什么时候会超时"><strong>HTTP 如何实现长连接？在什么时候会超时？</strong></a></li>
        <li><a href="#说说-dns-的解析过程"><strong>说说 DNS 的解析过程？</strong></a></li>
        <li><a href="#聊聊五层计算机网络体系结构中每一层对应的网络协议有哪些"><strong>聊聊五层计算机网络体系结构中，每一层对应的网络协议有哪些？</strong></a></li>
        <li><a href="#说说-websocket-与-socket-的区别"><strong>说说 WebSocket 与 socket 的区别</strong></a></li>
        <li><a href="#http-请求的过程与原理"><strong>Http 请求的过程与原理</strong></a></li>
        <li><a href="#ip-地址有哪些分类"><strong>IP 地址有哪些分类？</strong></a></li>
        <li><a href="#说下-arp-协议的工作过程"><strong>说下 ARP 协议的工作过程？</strong></a></li>
        <li><a href="#什么是arp呢">什么是arp呢？</a></li>
        <li><a href="#有了-ip-地址为什么还要用-mac-地址"><strong>有了 IP 地址，为什么还要用 MAC 地址？</strong></a></li>
        <li><a href="#tcp-和-udp-分别对应的常见应用层协议有哪些"><strong>TCP 和 UDP 分别对应的常见应用层协议有哪些？</strong></a></li>
        <li><a href="#聊聊保活计时器的作用"><strong>聊聊保活计时器的作用</strong></a></li>
        <li><a href="#如果服务器出现了大量-close_wait-状态如何解决"><strong>如果服务器出现了大量 CLOSE_WAIT 状态如何解决。</strong></a></li>
        <li><a href="#uri-和-url-的区别"><strong>URI 和 URL 的区别</strong></a></li>
        <li><a href="#icmp-协议的功能"><strong>ICMP 协议的功能</strong></a></li>
        <li><a href="#说下-ping-的原理"><strong>说下 ping 的原理</strong></a></li>
        <li><a href="#请详细介绍一下-tcp-的三次握手机制"><strong>请详细介绍一下 TCP 的三次握手机制</strong></a></li>
        <li><a href="#tcp-握手为什么是三次为什么不能是两次不能是四次"><strong>TCP 握手为什么是三次，为什么不能是两次？不能是四次？</strong></a></li>
        <li><a href="#说说-tcp-四次挥手过程"><strong>说说 TCP 四次挥手过程</strong></a></li>
        <li><a href="#tcp-挥手为什么需要四次呢"><strong>TCP 挥手为什么需要四次呢？</strong></a></li>
        <li><a href="#tcp-四次挥手过程中为什么需要等待-2msl-才进入-closed-关闭状态"><strong>TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态</strong></a></li>
        <li><a href="#tcp-的粘包和拆包"><strong>TCP 的粘包和拆包</strong></a></li>
        <li><a href="#聊聊-tcp-的流量控制"><strong>聊聊 TCP 的流量控制</strong></a></li>
        <li><a href="#说说半连接队列和-syn-flood-攻击的关系"><strong>说说半连接队列和 SYN Flood 攻击的关系</strong></a></li>
        <li><a href="#聊聊-tcp-的滑动窗口"><strong>聊聊 TCP 的滑动窗口</strong></a></li>
        <li><a href="#tcp-的拥塞控制"><strong>TCP 的拥塞控制</strong></a></li>
        <li><a href="#慢启动算法"><strong>慢启动算法</strong></a></li>
        <li><a href="#拥塞避免算法"><strong>拥塞避免算法</strong></a></li>
        <li><a href="#拥塞发生"><strong>拥塞发生</strong></a></li>
        <li><a href="#快速恢复"><strong>快速恢复</strong></a></li>
        <li><a href="#说说-tcp-是如何确保可靠性的呢"><strong>说说 TCP 是如何确保可靠性的呢？</strong></a></li>
        <li><a href="#说说-tcp-报文首部有哪些字段其作用又分别是什么"><strong>说说 TCP 报文首部有哪些字段，其作用又分别是什么？</strong></a></li>
        <li><a href="#说说-tcp-的重传机制"><strong>说说 TCP 的重传机制</strong></a></li>
        <li><a href="#501-超时重传"><strong>50.1 超时重传</strong></a></li>
        <li><a href="#502-快速重传"><strong>50.2 快速重传</strong></a></li>
        <li><a href="#503-带选择确认的重传sack"><strong>50.3 带选择确认的重传（SACK）</strong></a></li>
        <li><a href="#504-重复-sackd-sack"><strong>50.4 重复 SACK（D-SACK）</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
  </nav>


  </div>

      </main>

      <footer id="footer" class="footer">
        <div class="icon-links">
  











</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    2023
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        啊沉
        
      </span></span>

  
  

  
</div>

      </footer>

      <div class="button__back-to-top">
        <a href="#back-to-top">
          <i class="iconfont">
            
            <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

          </i>
        </a>
      </div>
    </div>
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>




<script type="text/javascript" src="/js/main.207927e62f08293c8ccfc5db5b7feb4c49f76a0455cb88c03da2ca8d1f8c015a.js" integrity="sha256-IHkn5i8IKTyMz8XbW3/rTEn3agRVy4jAPaLKjR&#43;MAVo=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.js" integrity="sha256-AC9ChpELidrhGHX23ZU53vmRdz3FhKaN9E28+BbcWBw=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js" integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin="anonymous"></script>
  

















  </body>
</html>
